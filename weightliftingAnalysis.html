<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>舉重影片分析工具</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/flowbite/1.8.0/flowbite.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.2/dist/chartjs-plugin-annotation.min.js"></script>
    <!-- OpenCV.js 库 -->
    <script>
        // 預先加載OpenCV處理函數
        function loadOpenCV() {
            const script = document.createElement('script');
            script.setAttribute('async', '');
            script.setAttribute('src', 'https://docs.opencv.org/4.8.0/opencv.js');
            script.setAttribute('onload', 'onOpenCvReady();');
            script.setAttribute('onerror', 'onOpenCvError();');
            document.head.appendChild(script);
        }
        // 在DOMContentLoaded後加載OpenCV
        document.addEventListener('DOMContentLoaded', loadOpenCV);</script>
    <!-- PoseNet 用於骨架分析 -->
    <script>
        // 預先加載TensorFlow處理函數
        function loadTensorFlow() {
            return new Promise((resolve, reject) => {
                const script1 = document.createElement('script');
                script1.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs';
                script1.onload = () => {
                    const script2 = document.createElement('script');
                    script2.src = 'https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet';
                    script2.onload = resolve;
                    script2.onerror = reject;
                    document.head.appendChild(script2);
                };
                script1.onerror = reject;
                document.head.appendChild(script1);
            });
        }

        // 在頁面加載完成後加載TensorFlow和PoseNet
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await loadTensorFlow();
                console.log('TensorFlow and PoseNet loaded');
                // 會觸發後續加載PoseNet模型
                initPoseNetModel();
            } catch (error) {
                console.error('Error loading TensorFlow or PoseNet', error);
                showPoseNetError('無法加載骨架分析模型，請檢查網絡連接或嘗試刷新頁面');
            }
        });</script>
    <style>
        :root {
            --primary-color: #5D5CDE;
            --light-bg: #FFFFFF;
            --dark-bg: #181818;
            --light-text: #333333;
            --dark-text: #F0F0F0;
            --light-border: #E5E7EB;
            --dark-border: #374151;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: var(--dark-bg);
                color: var(--dark-text);
            }

            .card {
                background-color: #242424;
                border-color: var(--dark-border);
            }

            input, select, textarea, button {
                background-color: #2A2A2A;
                border-color: var(--dark-border);
                color: var(--dark-text);
            }

            .text-gray-700, .text-gray-600 {
                color: #A0AEC0;
            }

            canvas {
                background-color: #2A2A2A;
                border-color: var(--dark-border);
            }

            .compare-overlay {
                background-color: rgba(30, 30, 30, 0.7);
            }

            .tab {
                background-color: #242424;
                color: var(--dark-text);
                border-color: var(--dark-border);
            }

                .tab.active {
                    background-color: var(--primary-color);
                    color: white;
                }

            .slider-container .slider-track {
                background-color: #4B5563;
            }

            .range-slider .slider-track {
                background-color: #4B5563;
            }

            .range-slider .slider-selection {
                background-color: var(--primary-color);
            }

            .text-secondary {
                color: #9CA3AF;
            }

            .border-gray-200 {
                border-color: #374151;
            }

            .bg-gray-50 {
                background-color: #242424;
            }

            .text-gray-500 {
                color: #9CA3AF;
            }

            .border-gray-300 {
                border-color: #4B5563;
            }

            .video-controls {
                background-color: rgba(30, 30, 30, 0.7);
            }

            .angle-overlay {
                background-color: rgba(30, 30, 30, 0.7);
                border-color: #4B5563;
            }

            .metrics-card {
                background-color: #242424;
                border-color: #374151;
            }

            .chart-container {
                border-color: #374151;
                background-color: #242424;
            }

            .permission-dialog {
                background-color: #333;
                color: #fff;
                border-color: #555;
            }

                .permission-dialog button.primary {
                    background-color: var(--primary-color);
                    color: white;
                }

                .permission-dialog button.secondary {
                    background-color: #4B5563;
                    color: white;
                }
        }

        @media (prefers-color-scheme: light) {
            body {
                background-color: var(--light-bg);
                color: var(--light-text);
            }

            .card {
                background-color: white;
                border-color: var(--light-border);
            }

            input, select, textarea, button {
                background-color: white;
                border-color: var(--light-border);
                color: var(--light-text);
            }

            canvas {
                background-color: #F9FAFB;
                border-color: var(--light-border);
            }

            .compare-overlay {
                background-color: rgba(240, 240, 240, 0.7);
            }

            .tab {
                background-color: #F3F4F6;
                color: var(--light-text);
                border-color: var(--light-border);
            }

                .tab.active {
                    background-color: var(--primary-color);
                    color: white;
                }

            .text-secondary {
                color: #6B7280;
            }

            .video-controls {
                background-color: rgba(240, 240, 240, 0.7);
            }

            .angle-overlay {
                background-color: rgba(240, 240, 240, 0.7);
                border-color: #E5E7EB;
            }

            .metrics-card {
                background-color: white;
                border-color: #E5E7EB;
            }

            .chart-container {
                border-color: #E5E7EB;
                background-color: white;
            }

            .permission-dialog {
                background-color: #fff;
                color: #333;
                border-color: #ddd;
            }

                .permission-dialog button.primary {
                    background-color: var(--primary-color);
                    color: white;
                }

                .permission-dialog button.secondary {
                    background-color: #E5E7EB;
                    color: #333;
                }
        }

        /* 應用總體樣式 */
        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .tracking-canvas, .tracking-overlay, .skeleton-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .video-wrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-color: #000;
        }

            .video-wrapper video {
                display: block;
                width: 100%;
                height: auto;
            }

        .compare-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-color: #000;
        }

        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            transition: opacity 0.2s;
            opacity: 0.8;
        }

            .slider:hover {
                opacity: 1;
            }

            .slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: var(--primary-color);
                cursor: pointer;
                transition: all 0.2s;
            }

                .slider::-webkit-slider-thumb:hover {
                    transform: scale(1.1);
                }

            .slider::-moz-range-thumb {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: var(--primary-color);
                cursor: pointer;
                transition: all 0.2s;
            }

                .slider::-moz-range-thumb:hover {
                    transform: scale(1.1);
                }

        .tab-container {
            display: flex;
            overflow-x: auto;
            margin-bottom: 1rem;
            border-bottom: 1px solid;
            scrollbar-width: thin;
            -ms-overflow-style: none;
        }

            .tab-container::-webkit-scrollbar {
                height: 4px;
            }

            .tab-container::-webkit-scrollbar-thumb {
                background-color: var(--primary-color);
                border-radius: 4px;
            }

        .tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border: 1px solid;
            border-bottom: none;
            border-radius: 0.5rem 0.5rem 0 0;
            margin-right: 0.25rem;
            transition: all 0.2s;
            flex-shrink: 0;
        }

            .tab:hover {
                background-color: rgba(93, 92, 222, 0.1);
            }

        .chart-container {
            height: 300px;
            width: 100%;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid;
            margin-top: 1rem;
            position: relative;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* 編輯控件樣式 */
        .range-slider {
            position: relative;
            height: 30px;
            width: 100%;
            margin: 1.5rem 0;
        }

            .range-slider .slider-track {
                position: absolute;
                height: 8px;
                background: #ddd;
                width: calc(100% - 20px);
                margin: 0 10px;
                top: 50%;
                transform: translateY(-50%);
                border-radius: 5px;
            }

            .range-slider .slider-selection {
                position: absolute;
                height: 100%;
                background: var(--primary-color);
                border-radius: 5px;
            }

            .range-slider .slider-handle {
                position: absolute;
                width: 24px;
                height: 24px;
                background: white;
                border: 2px solid var(--primary-color);
                border-radius: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                cursor: grab;
                z-index: 1;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                transition: transform 0.1s, box-shadow 0.1s;
            }

                .range-slider .slider-handle:hover {
                    transform: translate(-50%, -50%) scale(1.1);
                    box-shadow: 0 3px 6px rgba(0,0,0,0.3);
                }

                .range-slider .slider-handle:active {
                    cursor: grabbing;
                    transform: translate(-50%, -50%) scale(1.15);
                    box-shadow: 0 4px 8px rgba(0,0,0,0.4);
                }

        .rotate-handle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(93, 92, 222, 0.8);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: transform 0.2s, background-color 0.2s;
        }

            .rotate-handle:hover {
                transform: scale(1.1);
                background: rgba(93, 92, 222, 1);
            }

        .crop-area {
            position: absolute;
            border: 2px dashed var(--primary-color);
            z-index: 5;
            pointer-events: none;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
        }

        .time-label {
            position: absolute;
            bottom: -25px;
            transform: translateX(-50%);
            font-size: 12px;
            color: var(--text-secondary);
            white-space: nowrap;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 2px 6px;
            border-radius: 10px;
        }

        /* OpenCV 和 PoseNet 狀態顯示 */
        #opencvStatus, #poseNetStatus {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 8px;
            background-color: #f8d7da;
            color: #721c24;
            text-align: center;
            z-index: 1000;
            display: none;
            animation: statusFadeIn 0.3s ease-in-out;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        @keyframes statusFadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .status-ready {
            background-color: #d4edda !important;
            color: #155724 !important;
        }

        .rotate-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 1.5rem;
            flex-wrap: wrap;
            gap: 0.5rem;
            background: rgba(240, 240, 240, 0.1);
            padding: 1rem;
            border-radius: 0.5rem;
        }

        .rotate-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            margin: 0 5px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

            .rotate-button:hover {
                transform: scale(1.08);
                box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            }

            .rotate-button:active {
                transform: scale(0.95);
            }

        .rotate-fine-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            margin: 0 2px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

            .rotate-fine-button:hover {
                transform: scale(1.08);
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }

        .rotate-input {
            width: 60px;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            border: 1px solid var(--light-border);
            border-radius: 4px;
            padding: 4px;
            margin: 0 5px;
        }

        /* 追蹤點選擇器 */
        .point-selector {
            position: absolute;
            display: none;
            width: 120px;
            height: 120px;
            border: 3px solid yellow;
            border-radius: 50%;
            pointer-events: none;
            z-index: 15;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(255, 255, 0, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 255, 0, 0);
            }
        }

        .point-selector::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background-color: yellow;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px yellow;
        }

        .point-selector-instruction {
            position: absolute;
            bottom: -45px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 14px;
            white-space: nowrap;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 20;
        }

        /* 進度條樣式 */
        .progress-bar-container {
            width: 100%;
            height: 10px;
            background-color: rgba(200, 200, 200, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color) 0%, #8584e6 100%);
            width: 0%;
            transition: width 0.3s;
            border-radius: 5px;
            background-size: 30px 30px;
            background-image: linear-gradient( 135deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent );
            animation: progress-animation 1s linear infinite;
        }

        @keyframes progress-animation {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 30px 0;
            }
        }

        /* 骨架分析樣式 */
        .skeleton-point {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.8);
        }

        .skeleton-line {
            position: absolute;
            height: 3px;
            background-color: yellow;
            transform-origin: 0 50%;
            box-shadow: 0 0 5px rgba(255, 255, 0, 0.6);
        }

        /* 角度標記樣式 */
        .angle-marker {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid lime;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
        }

        .angle-text {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
            z-index: 10;
        }

        /* 影片控制樣式 */
        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            backdrop-filter: blur(5px);
            border-radius: 0 0 0.5rem 0.5rem;
            transition: opacity 0.3s;
        }

        .video-wrapper:hover .video-controls {
            opacity: 1;
        }

        .video-control-button {
            background-color: rgba(93, 92, 222, 0.9);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            margin: 0 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

            .video-control-button:hover {
                background-color: rgba(93, 92, 222, 1);
                transform: translateY(-2px);
                box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            }

            .video-control-button:active {
                transform: translateY(0);
                box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            }

            .video-control-button svg {
                width: 16px;
                height: 16px;
                fill: currentColor;
                margin-right: 4px;
            }

        /* 角度疊加層 */
        .angle-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid;
            font-size: 13px;
            z-index: 5;
            backdrop-filter: blur(8px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.3s;
            max-width: 200px;
            opacity: 0.9;
        }

            .angle-overlay:hover {
                opacity: 1;
                transform: translateY(-5px);
            }

        .angle-value {
            font-weight: bold;
            color: var(--primary-color);
        }

        /* 關節選擇器 */
        .joint-selector {
            margin-top: 1rem;
            background: rgba(240, 240, 240, 0.1);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--light-border);
        }

        .joint-checkbox {
            margin-right: 5px;
            accent-color: var(--primary-color);
            width: 16px;
            height: 16px;
        }

        .joint-label {
            display: inline-flex;
            align-items: center;
            margin-right: 1rem;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

            .joint-label:hover {
                background-color: rgba(93, 92, 222, 0.1);
            }

        /* 播放速度控制 */
        .playback-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            gap: 4px;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 3px 8px;
            border-radius: 20px;
        }

        .speed-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            color: white;
        }

        /* 指標卡片樣式 */
        .metrics-card {
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            border: 1px solid;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

            .metrics-card:hover {
                box-shadow: 0 5px 15px rgba(0,0,0,0.1);
                transform: translateY(-2px);
            }

        .metrics-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
            display: inline-block;
        }

        .metrics-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .metrics-label {
            font-size: 0.875rem;
            opacity: 0.8;
        }

        /* 權限對話框 */
        .permission-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            display: none;
            animation: dialogFadeIn 0.3s ease-out;
        }

        @keyframes dialogFadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .permission-dialog h3 {
            margin-top: 0;
            font-size: 1.2rem;
            margin-bottom: 1rem;
        }

        .permission-dialog p {
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }

        .permission-dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        .permission-dialog button {
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

            .permission-dialog button:hover {
                transform: translateY(-2px);
                box-shadow: 0 3px 5px rgba(0, 0, 0, 0.2);
            }

        .permission-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 999;
            display: none;
        }

        /* 自適應調整 */
        @media (max-width: 640px) {
            .rotate-controls {
                flex-direction: column;
                gap: 1rem;
            }

            .video-controls {
                flex-wrap: wrap;
                gap: 5px;
                padding: 8px;
            }

            .video-control-button {
                padding: 4px 8px;
                font-size: 12px;
                margin: 2px;
            }

            .angle-overlay {
                font-size: 11px;
                padding: 6px;
                max-width: 160px;
            }

            .joint-label {
                margin-bottom: 5px;
            }

            .tab {
                padding: 0.3rem 0.7rem;
                font-size: 0.9rem;
            }
        }

        /* 視訊容器旋轉樣式 */
        .video-container-wrapper {
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-container {
            position: relative;
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="opencvStatus" class="opacity-0">
        正在載入 OpenCV.js...
    </div>

    <div id="poseNetStatus" class="opacity-0">
        正在載入 PoseNet...
    </div>

    <div id="permissionDialog" class="permission-dialog">
        <h3>需要相機和模型權限</h3>
        <p>為了使用骨架分析功能，我們需要載入PoseNet模型並使用您的相機進行分析。請允許本應用程式存取這些功能以獲得完整體驗。</p>
        <div class="permission-dialog-buttons">
            <button class="secondary" onclick="denyPoseNetPermission()">暫時不用</button>
            <button class="primary" onclick="allowPoseNetPermission()">允許</button>
        </div>
    </div>
    <div id="permissionOverlay" class="permission-dialog-overlay"></div>

    <div class="app-container">
        <h1 class="text-3xl font-bold text-center mb-6">舉重影片分析工具</h1>

        <div class="card rounded-lg shadow-md p-4 mb-6">
            <h2 class="text-xl font-semibold mb-4">上傳舉重影片</h2>
            <div class="space-y-4">
                <div>
                    <label for="videoUpload" class="block mb-2 text-sm font-medium">選擇影片檔案</label>
                    <input type="file" id="videoUpload" accept="video/*" class="block w-full text-base border rounded-lg cursor-pointer focus:outline-none p-2.5">
                    <p class="mt-2 text-sm text-gray-500">支援所有常見影片格式 (MP4, MOV, AVI, WEBM 等)</p>
                </div>

                <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
                    <div class="w-full sm:w-1/2">
                        <label for="weightInput" class="block mb-2 text-sm font-medium">槓鈴重量 (公斤)</label>
                        <input type="number" id="weightInput" class="block w-full text-base border rounded-lg p-2.5" placeholder="例如: 100">
                    </div>
                    <div class="w-full sm:w-1/2">
                        <label for="athleteHeight" class="block mb-2 text-sm font-medium">運動員身高 (公分)</label>
                        <input type="number" id="athleteHeight" class="block w-full text-base border rounded-lg p-2.5" placeholder="例如: 175">
                    </div>
                </div>

                <button id="startEditingBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg text-base px-5 py-2.5 text-center transition transform hover:scale-105 active:scale-95">
                    預覽並編輯影片
                </button>
            </div>
        </div>

        <div id="editingSection" class="hidden">
            <div class="card rounded-lg shadow-md p-4 mb-6">
                <h2 class="text-xl font-semibold mb-4">影片編輯</h2>

                <div class="video-container-wrapper mb-8">
                    <div id="videoContainer" class="video-container">
                        <div class="video-wrapper">
                            <video id="editVideoPlayer" class="rounded-lg" controls></video>
                            <canvas id="editOverlay" class="tracking-overlay"></canvas>
                            <div id="cropArea" class="crop-area hidden"></div>
                            <div id="rotateHandle" class="rotate-handle hidden">&#8635;</div>
                        </div>
                    </div>
                </div>

                <div class="mb-6">
                    <h3 class="font-medium mb-2">裁剪影片時間段</h3>
                    <div class="range-slider mb-6">
                        <div class="slider-track"></div>
                        <div id="timeSliderSelection" class="slider-selection"></div>
                        <div id="startTimeHandle" class="slider-handle"></div>
                        <div id="endTimeHandle" class="slider-handle"></div>
                        <div id="startTimeLabel" class="time-label">0:00</div>
                        <div id="endTimeLabel" class="time-label">0:00</div>
                    </div>

                    <div class="text-center text-sm text-secondary mt-8">
                        <span id="currentTime">當前時間: 0:00</span> / <span id="totalTime">總時長: 0:00</span>
                    </div>
                </div>

                <div class="mb-6">
                    <h3 class="font-medium mb-2">旋轉影片</h3>
                    <div class="rotate-controls">
                        <div id="rotateLargeLeft" class="rotate-button" title="向左旋轉90度">&#8634;</div>
                        <div id="rotateLeft" class="rotate-fine-button" title="向左旋轉1度">-1°</div>
                        <div class="flex items-center">
                            <input type="number" id="rotationAngleInput" class="rotate-input" value="0" min="-180" max="180" step="1">
                            <span class="ml-1">°</span>
                        </div>
                        <div id="rotateRight" class="rotate-fine-button" title="向右旋轉1度">+1°</div>
                        <div id="rotateLargeRight" class="rotate-button" title="向右旋轉90度">&#8635;</div>
                    </div>
                </div>

                <div class="flex space-x-2">
                    <button id="cancelEditBtn" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-medium rounded-lg text-sm px-4 py-2 transition transform hover:scale-105 active:scale-95">取消</button>
                    <button id="applyEditBtn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg text-sm px-4 py-2 transition transform hover:scale-105 active:scale-95">套用變更並開始分析</button>
                </div>
            </div>
        </div>

        <div id="analysisSection" class="hidden">
            <div class="card rounded-lg shadow-md p-4 mb-6">
                <h2 class="text-xl font-semibold mb-4">影片分析</h2>

                <div class="video-container-wrapper mb-4">
                    <div id="analysisVideoContainer" class="video-container">
                        <div class="video-wrapper">
                            <video id="videoPlayer" class="rounded-lg" controls></video>
                            <canvas id="trackingOverlay" class="tracking-overlay"></canvas>
                            <canvas id="skeletonOverlay" class="skeleton-overlay"></canvas>
                            <div id="angleOverlay" class="angle-overlay hidden">
                                <div class="mb-1">膝關節角度: <span id="kneeAngle" class="angle-value">-</span>°</div>
                                <div class="mb-1">髖關節角度: <span id="hipAngle" class="angle-value">-</span>°</div>
                                <div class="mb-1">肩關節角度: <span id="shoulderAngle" class="angle-value">-</span>°</div>
                                <div>肘關節角度: <span id="elbowAngle" class="angle-value">-</span>°</div>
                            </div>
                            <div id="pointSelector" class="point-selector">
                                <div class="point-selector-instruction">點擊選擇要追蹤的槓鈴位置</div>
                            </div>
                            <div id="loadingIndicator" class="loading hidden">
                                <div class="mb-2">處理中...</div>
                                <div class="progress-bar-container">
                                    <div id="analysisProgress" class="progress-bar"></div>
                                </div>
                            </div>

                            <div class="video-controls">
                                <button id="playPauseBtn" class="video-control-button">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                                        <path d="M8 5v14l11-7z" />
                                    </svg>
                                    播放
                                </button>
                                <button id="prevFrameBtn" class="video-control-button">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                                        <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z" />
                                    </svg>
                                    上一幀
                                </button>
                                <button id="nextFrameBtn" class="video-control-button">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                                        <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" />
                                    </svg>
                                    下一幀
                                </button>
                                <div class="playback-controls">
                                    <button id="decreaseSpeedBtn" class="video-control-button">-</button>
                                    <span id="speedValue" class="speed-value">1.0x</span>
                                    <button id="increaseSpeedBtn" class="video-control-button">+</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flex flex-wrap gap-2 mb-4">
                    <button id="selectTrackPoint" class="bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95">選擇追蹤點</button>
                    <button id="trackBarbell" class="bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95">開始追蹤</button>
                    <button id="stopTracking" class="bg-yellow-500 hover:bg-yellow-600 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95 hidden">停止追蹤</button>
                    <button id="resetTracking" class="bg-gray-500 hover:bg-gray-600 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95">重設追蹤</button>
                    <button id="toggleSkeleton" class="bg-purple-600 hover:bg-purple-700 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95">顯示骨架</button>
                    <button id="toggleAngles" class="bg-green-600 hover:bg-green-700 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95">顯示關節角度</button>
                    <button id="markKeyPoint" class="bg-green-600 hover:bg-green-700 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95 hidden">標記關鍵點</button>
                    <select id="keyPointType" class="rounded-lg text-sm py-2 hidden">
                        <option value="start">起始點</option>
                        <option value="firstPull">第一拉</option>
                        <option value="powerPosition">發力點</option>
                        <option value="secondPull">第二拉</option>
                        <option value="catch">接槓點</option>
                        <option value="liftStart">拉起槓鈴時</option>
                    </select>
                </div>

                <div class="joint-selector mb-4">
                    <h3 class="font-medium mb-2">選擇顯示的關節</h3>
                    <div class="flex flex-wrap gap-3">
                        <label class="joint-label">
                            <input type="checkbox" class="joint-checkbox" value="knee" checked> 膝關節
                        </label>
                        <label class="joint-label">
                            <input type="checkbox" class="joint-checkbox" value="hip" checked> 髖關節
                        </label>
                        <label class="joint-label">
                            <input type="checkbox" class="joint-checkbox" value="shoulder" checked> 肩關節
                        </label>
                        <label class="joint-label">
                            <input type="checkbox" class="joint-checkbox" value="elbow" checked> 肘關節
                        </label>
                        <label class="joint-label">
                            <input type="checkbox" class="joint-checkbox" value="ankle"> 踝關節
                        </label>
                        <label class="joint-label">
                            <input type="checkbox" class="joint-checkbox" value="wrist"> 腕關節
                        </label>
                    </div>
                </div>

                <div class="tab-container" id="analysisTabs">
                    <div class="tab active" data-tab="trajectory">軌跡分析</div>
                    <div class="tab" data-tab="velocity">速度分析</div>
                    <div class="tab" data-tab="power">功率分析</div>
                    <div class="tab" data-tab="displacement">位移分析</div>
                    <div class="tab" data-tab="angles">角度分析</div>
                    <div class="tab" data-tab="metrics">其他指標</div>
                </div>

                <div id="trajectoryTab" class="tab-content">
                    <div class="chart-container">
                        <canvas id="trajectoryCanvas" height="400"></canvas>
                    </div>
                </div>

                <div id="velocityTab" class="tab-content hidden">
                    <div class="chart-container">
                        <canvas id="velocityChart"></canvas>
                    </div>
                </div>

                <div id="powerTab" class="tab-content hidden">
                    <div class="chart-container">
                        <canvas id="powerChart"></canvas>
                    </div>
                </div>

                <div id="displacementTab" class="tab-content hidden">
                    <div class="chart-container">
                        <canvas id="displacementChart"></canvas>
                    </div>
                </div>

                <div id="anglesTab" class="tab-content hidden">
                    <div class="chart-container">
                        <canvas id="anglesChart"></canvas>
                    </div>
                </div>

                <div id="metricsTab" class="tab-content hidden">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                        <div class="metrics-card">
                            <div class="metrics-title">最大槓鈴高度</div>
                            <div class="metrics-value" id="maxHeight">-</div>
                            <div class="metrics-label">運動員能夠將槓鈴提升的最大高度</div>
                        </div>
                        <div class="metrics-card">
                            <div class="metrics-title">拉起效率</div>
                            <div class="metrics-value" id="liftEfficiency">-</div>
                            <div class="metrics-label">垂直位移與水平位移的比率，越高越好</div>
                        </div>
                        <div class="metrics-card">
                            <div class="metrics-title">第一拉時間</div>
                            <div class="metrics-value" id="firstPullTime">-</div>
                            <div class="metrics-label">從起始點到發力點的時間</div>
                        </div>
                        <div class="metrics-card">
                            <div class="metrics-title">第二拉時間</div>
                            <div class="metrics-value" id="secondPullTime">-</div>
                            <div class="metrics-label">從發力點到接槓點的時間</div>
                        </div>
                        <div class="metrics-card">
                            <div class="metrics-title">發力時膝關節角度</div>
                            <div class="metrics-value" id="powerKneeAngle">-</div>
                            <div class="metrics-label">發力階段膝關節彎曲角度</div>
                        </div>
                        <div class="metrics-card">
                            <div class="metrics-title">發力時髖關節角度</div>
                            <div class="metrics-value" id="powerHipAngle">-</div>
                            <div class="metrics-label">發力階段髖關節彎曲角度</div>
                        </div>
                        <div class="metrics-card">
                            <div class="metrics-title">最大速度</div>
                            <div class="metrics-value" id="maxVelocity">-</div>
                            <div class="metrics-label">槓鈴達到的最大垂直速度</div>
                        </div>
                        <div class="metrics-card">
                            <div class="metrics-title">最大功率</div>
                            <div class="metrics-value" id="maxPower">-</div>
                            <div class="metrics-label">運動員產生的最大功率輸出</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card rounded-lg shadow-md p-4 mb-6">
                <h2 class="text-xl font-semibold mb-4">影片比較</h2>

                <div class="mb-4">
                    <label for="compareVideoUpload" class="block mb-2 text-sm font-medium">上傳比較影片</label>
                    <input type="file" id="compareVideoUpload" accept="video/*" class="block w-full text-base border rounded-lg cursor-pointer focus:outline-none p-2.5">
                    <p class="mt-2 text-sm text-gray-500">支援所有常見影片格式 (MP4, MOV, AVI, WEBM 等)</p>
                </div>

                <div id="compareContainer" class="hidden">
                    <div class="video-container-wrapper mb-4">
                        <div id="compareVideoContainer" class="video-container">
                            <div class="compare-container">
                                <video id="compareVideoPlayer" class="rounded-lg" controls></video>
                                <canvas id="compareOverlay" class="tracking-overlay"></canvas>
                                <canvas id="compareSkeletonOverlay" class="skeleton-overlay"></canvas>
                                <div id="compareAngleOverlay" class="angle-overlay hidden">
                                    <div class="mb-1">膝關節角度: <span id="compareKneeAngle" class="angle-value">-</span>°</div>
                                    <div class="mb-1">髖關節角度: <span id="compareHipAngle" class="angle-value">-</span>°</div>
                                    <div class="mb-1">肩關節角度: <span id="compareShoulderAngle" class="angle-value">-</span>°</div>
                                    <div>肘關節角度: <span id="compareElbowAngle" class="angle-value">-</span>°</div>
                                </div>
                                <div id="comparePointSelector" class="point-selector">
                                    <div class="point-selector-instruction">點擊選擇要追蹤的槓鈴位置</div>
                                </div>
                                <div id="compareLoadingIndicator" class="loading hidden">
                                    <div class="mb-2">處理中...</div>
                                    <div class="progress-bar-container">
                                        <div id="compareProgress" class="progress-bar"></div>
                                    </div>
                                </div>

                                <div class="video-controls">
                                    <button id="comparePlayPauseBtn" class="video-control-button">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                                            <path d="M8 5v14l11-7z" />
                                        </svg>
                                        播放
                                    </button>
                                    <button id="comparePrevFrameBtn" class="video-control-button">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                                            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z" />
                                        </svg>
                                        上一幀
                                    </button>
                                    <button id="compareNextFrameBtn" class="video-control-button">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                                            <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" />
                                        </svg>
                                        下一幀
                                    </button>
                                    <div class="playback-controls">
                                        <button id="compareDecreaseSpeedBtn" class="video-control-button">-</button>
                                        <span id="compareSpeedValue" class="speed-value">1.0x</span>
                                        <button id="compareIncreaseSpeedBtn" class="video-control-button">+</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="flex flex-wrap gap-2 mb-4">
                        <button id="selectCompareTrackPoint" class="bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95">選擇追蹤點</button>
                        <button id="trackCompare" class="bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95">開始追蹤</button>
                        <button id="stopCompareTracking" class="bg-yellow-500 hover:bg-yellow-600 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95 hidden">停止追蹤</button>
                        <button id="resetCompareTracking" class="bg-gray-500 hover:bg-gray-600 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95">重設追蹤</button>
                        <button id="toggleCompareSkeleton" class="bg-purple-600 hover:bg-purple-700 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95">顯示骨架</button>
                        <button id="toggleCompareAngles" class="bg-green-600 hover:bg-green-700 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95">顯示關節角度</button>
                        <button id="markCompareKeyPoint" class="bg-green-600 hover:bg-green-700 text-white font-medium rounded-lg text-sm px-4 py-2 transition hover:scale-105 active:scale-95 hidden">標記關鍵點</button>
                        <select id="compareKeyPointType" class="rounded-lg text-sm py-2 hidden">
                            <option value="start">起始點</option>
                            <option value="firstPull">第一拉</option>
                            <option value="powerPosition">發力點</option>
                            <option value="secondPull">第二拉</option>
                            <option value="catch">接槓點</option>
                            <option value="liftStart">拉起槓鈴時</option>
                        </select>
                    </div>

                    <div class="mb-4">
                        <label for="opacitySlider" class="block mb-2 text-sm font-medium">調整重疊透明度</label>
                        <input type="range" id="opacitySlider" class="slider" min="0" max="100" value="50">
                    </div>

                    <div class="mb-4">
                        <label for="syncPoint" class="block mb-2 text-sm font-medium">選擇同步點</label>
                        <select id="syncPoint" class="block w-full text-base border rounded-lg p-2.5">
                            <option value="powerPosition" selected>發力點(三關節爆發)</option>
                            <option value="liftStart">拉起槓鈴時</option>
                            <option value="start">起始點</option>
                            <option value="firstPull">第一拉</option>
                            <option value="secondPull">第二拉</option>
                            <option value="catch">接槓點</option>
                        </select>
                    </div>

                    <button id="syncVideos" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg text-base px-5 py-2.5 text-center transition hover:scale-105 active:scale-95 mb-4">
                        同步比較影片
                    </button>

                    <div class="tab-container" id="comparisonTabs">
                        <div class="tab active" data-tab="trajectoryCompare">軌跡比較</div>
                        <div class="tab" data-tab="velocityCompare">速度比較</div>
                        <div class="tab" data-tab="powerCompare">功率比較</div>
                        <div class="tab" data-tab="displacementCompare">位移比較</div>
                        <div class="tab" data-tab="anglesCompare">角度比較</div>
                        <div class="tab" data-tab="metricsCompare">指標比較</div>
                    </div>

                    <div id="trajectoryCompareTab" class="tab-content">
                        <div class="chart-container">
                            <canvas id="trajectoryCompareCanvas" height="400"></canvas>
                        </div>
                    </div>

                    <div id="velocityCompareTab" class="tab-content hidden">
                        <div class="chart-container">
                            <canvas id="velocityCompareChart"></canvas>
                        </div>
                    </div>

                    <div id="powerCompareTab" class="tab-content hidden">
                        <div class="chart-container">
                            <canvas id="powerCompareChart"></canvas>
                        </div>
                    </div>

                    <div id="displacementCompareTab" class="tab-content hidden">
                        <div class="chart-container">
                            <canvas id="displacementCompareChart"></canvas>
                        </div>
                    </div>

                    <div id="anglesCompareTab" class="tab-content hidden">
                        <div class="chart-container">
                            <canvas id="anglesCompareChart"></canvas>
                        </div>
                    </div>

                    <div id="metricsCompareTab" class="tab-content hidden">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                            <div class="metrics-card">
                                <div class="metrics-title">原始影片指標</div>
                                <table class="w-full">
                                    <tr>
                                        <td class="py-1">最大槓鈴高度:</td>
                                        <td class="py-1 text-right font-medium" id="origMaxHeight">-</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">拉起效率:</td>
                                        <td class="py-1 text-right font-medium" id="origLiftEfficiency">-</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">最大速度:</td>
                                        <td class="py-1 text-right font-medium" id="origMaxVelocity">-</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">最大功率:</td>
                                        <td class="py-1 text-right font-medium" id="origMaxPower">-</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">發力時膝關節角度:</td>
                                        <td class="py-1 text-right font-medium" id="origPowerKneeAngle">-</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">發力時髖關節角度:</td>
                                        <td class="py-1 text-right font-medium" id="origPowerHipAngle">-</td>
                                    </tr>
                                </table>
                            </div>

                            <div class="metrics-card">
                                <div class="metrics-title">比較影片指標</div>
                                <table class="w-full">
                                    <tr>
                                        <td class="py-1">最大槓鈴高度:</td>
                                        <td class="py-1 text-right font-medium" id="compMaxHeight">-</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">拉起效率:</td>
                                        <td class="py-1 text-right font-medium" id="compLiftEfficiency">-</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">最大速度:</td>
                                        <td class="py-1 text-right font-medium" id="compMaxVelocity">-</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">最大功率:</td>
                                        <td class="py-1 text-right font-medium" id="compMaxPower">-</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">發力時膝關節角度:</td>
                                        <td class="py-1 text-right font-medium" id="compPowerKneeAngle">-</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">發力時髖關節角度:</td>
                                        <td class="py-1 text-right font-medium" id="compPowerHipAngle">-</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全域變數
        let opencvReady = false;
        let poseNetReady = false;
        let poseNetModel = null;
        let poseNetAllowed = false;

        // OpenCV 加載狀態
        function onOpenCvReady() {
            console.log("OpenCV.js已載入！");
            opencvReady = true;
            const statusDiv = document.getElementById('opencvStatus');
            statusDiv.textContent = "OpenCV.js 已成功載入";
            statusDiv.style.display = "block";
            statusDiv.classList.add("status-ready");
            statusDiv.style.opacity = "1";

            // 3秒後隱藏狀態
            setTimeout(() => {
                statusDiv.style.opacity = "0";
                setTimeout(() => {
                    statusDiv.style.display = "none";
                }, 300);
            }, 3000);
        }

        function onOpenCvError() {
            console.error("OpenCV.js載入失敗！");
            const statusDiv = document.getElementById('opencvStatus');
            statusDiv.textContent = "無法載入OpenCV.js，請檢查網絡連接";
            statusDiv.style.display = "block";
            statusDiv.style.opacity = "1";

            setTimeout(() => {
                askForPermission("OpenCV.js",
                    "我們需要從外部資源加載OpenCV.js來進行影像處理。請允許加載此資源以啟用追蹤功能。",
                    reloadOpenCV);
            }, 1000);
        }

        function reloadOpenCV() {
            loadOpenCV();
        }

        // PoseNet 初始化
        async function initPoseNetModel() {
            try {
                const statusDiv = document.getElementById('poseNetStatus');
                statusDiv.textContent = "正在載入 PoseNet...";
                statusDiv.style.display = "block";
                statusDiv.style.opacity = "1";

                // 請求權限
                if (!poseNetAllowed) {
                    showPermissionDialog();
                    return;
                }

                // 如果已授權，加載模型
                try {
                    poseNetModel = await posenet.load({
                        architecture: 'MobileNetV1',
                        outputStride: 16,
                        inputResolution: { width: 640, height: 480 },
                        multiplier: 0.75
                    });

                    poseNetReady = true;
                    statusDiv.textContent = "PoseNet 已成功載入";
                    statusDiv.classList.add("status-ready");
                    statusDiv.style.opacity = "1";

                    // 3秒後隱藏狀態
                    setTimeout(() => {
                        statusDiv.style.opacity = "0";
                        setTimeout(() => {
                            statusDiv.style.display = "none";
                        }, 300);
                    }, 3000);

                    console.log("PoseNet model loaded");
                } catch (error) {
                    console.error("PoseNet loading error:", error);
                    showPoseNetError("無法載入PoseNet模型，請嘗試重新載入頁面");
                }
            } catch (error) {
                console.error("PoseNet initialization error:", error);
                showPoseNetError("無法初始化PoseNet，請檢查網絡連接");
            }
        }

        // 顯示權限對話框
        function showPermissionDialog() {
            document.getElementById('permissionDialog').style.display = 'block';
            document.getElementById('permissionOverlay').style.display = 'block';
        }

        // 允許PoseNet權限
        function allowPoseNetPermission() {
            poseNetAllowed = true;
            document.getElementById('permissionDialog').style.display = 'none';
            document.getElementById('permissionOverlay').style.display = 'none';

            // 加載PoseNet模型
            initPoseNetModel();
        }

        // 拒絕PoseNet權限
        function denyPoseNetPermission() {
            document.getElementById('permissionDialog').style.display = 'none';
            document.getElementById('permissionOverlay').style.display = 'none';

            // 顯示通知
            const statusDiv = document.getElementById('poseNetStatus');
            statusDiv.textContent = "已禁用骨架分析功能";
            statusDiv.style.display = "block";
            statusDiv.style.opacity = "1";
            statusDiv.classList.remove("status-ready");

            setTimeout(() => {
                statusDiv.style.opacity = "0";
                setTimeout(() => {
                    statusDiv.style.display = "none";
                }, 300);
            }, 3000);
        }

        // 顯示PoseNet錯誤
        function showPoseNetError(message) {
            const statusDiv = document.getElementById('poseNetStatus');
            statusDiv.textContent = message;
            statusDiv.style.display = "block";
            statusDiv.style.opacity = "1";
            statusDiv.classList.remove("status-ready");

            setTimeout(() => {
                askForPermission("PoseNet",
                    "無法載入骨架分析模型。這可能是由於瀏覽器設置或網絡問題。您想要重試嗎？",
                    initPoseNetModel);
            }, 1000);
        }

        // 請求權限通用函數
        function askForPermission(feature, message, callback) {
            const dialog = document.getElementById('permissionDialog');
            const overlay = document.getElementById('permissionOverlay');

            document.querySelector('#permissionDialog h3').textContent = `需要${feature}權限`;
            document.querySelector('#permissionDialog p').textContent = message;

            // 修改按鈕動作
            const allowBtn = document.querySelector('#permissionDialog button.primary');
            allowBtn.textContent = "允許";
            allowBtn.onclick = function () {
                dialog.style.display = 'none';
                overlay.style.display = 'none';
                if (callback) callback();
            };

            dialog.style.display = 'block';
            overlay.style.display = 'block';
        }

        // 主要數據儲存
        const analysisData = {
            trajectoryPoints: [],
            velocityData: [],
            powerData: [],
            displacementData: [],
            timePoints: [],
            angles: {
                knee: [],
                hip: [],
                shoulder: [],
                elbow: []
            },
            poses: [],
            keyPoints: {
                start: -1,
                firstPull: -1,
                powerPosition: -1,
                secondPull: -1,
                catch: -1,
                liftStart: -1
            },
            frameIndices: [], // 存儲幀索引與時間點的對應關係
            metrics: {
                maxHeight: 0,
                liftEfficiency: 0,
                maxVelocity: 0,
                maxPower: 0,
                firstPullTime: 0,
                secondPullTime: 0,
                powerKneeAngle: 0,
                powerHipAngle: 0
            }
        };

        const compareData = {
            trajectoryPoints: [],
            velocityData: [],
            powerData: [],
            displacementData: [],
            timePoints: [],
            angles: {
                knee: [],
                hip: [],
                shoulder: [],
                elbow: []
            },
            poses: [],
            keyPoints: {
                start: -1,
                firstPull: -1,
                powerPosition: -1,
                secondPull: -1,
                catch: -1,
                liftStart: -1
            },
            frameIndices: [],
            metrics: {
                maxHeight: 0,
                liftEfficiency: 0,
                maxVelocity: 0,
                maxPower: 0,
                firstPullTime: 0,
                secondPullTime: 0,
                powerKneeAngle: 0,
                powerHipAngle: 0
            }
        };

        // 編輯參數
        const editParams = {
            startTime: 0,
            endTime: 0,
            rotationAngle: 0,
            videoBlob: null
        };

        // 追蹤參數
        const trackingParams = {
            isTracking: false,
            trackPoint: { x: 0, y: 0 },
            isPointSelected: false,
            currentFrameIndex: 0,
            processingFrames: false,
            frameCount: 0,
            startFrameTime: 0,
            HSV_min: [0, 0, 0],  // 預設值，將在運行時計算
            HSV_max: [180, 255, 255],  // 預設值，將在運行時計算
            showSkeleton: false,
            showAngles: false,
            playbackRate: 1.0,
            activeJoints: {
                knee: true,
                hip: true,
                shoulder: true,
                elbow: true,
                ankle: false,
                wrist: false
            }
        };

        const compareTrackingParams = {
            isTracking: false,
            trackPoint: { x: 0, y: 0 },
            isPointSelected: false,
            currentFrameIndex: 0,
            processingFrames: false,
            frameCount: 0,
            startFrameTime: 0,
            HSV_min: [0, 0, 0],
            HSV_max: [180, 255, 255],
            showSkeleton: false,
            showAngles: false,
            playbackRate: 1.0,
            activeJoints: {
                knee: true,
                hip: true,
                shoulder: true,
                elbow: true,
                ankle: false,
                wrist: false
            }
        };

        // DOM 元素
        const videoUpload = document.getElementById('videoUpload');
        const weightInput = document.getElementById('weightInput');
        const athleteHeight = document.getElementById('athleteHeight');
        const startEditingBtn = document.getElementById('startEditingBtn');
        const cancelEditBtn = document.getElementById('cancelEditBtn');
        const applyEditBtn = document.getElementById('applyEditBtn');

        const editingSection = document.getElementById('editingSection');
        const analysisSection = document.getElementById('analysisSection');

        const videoContainer = document.getElementById('videoContainer');
        const editVideoPlayer = document.getElementById('editVideoPlayer');
        const editOverlay = document.getElementById('editOverlay');
        const cropArea = document.getElementById('cropArea');
        const rotateHandle = document.getElementById('rotateHandle');
        const startTimeHandle = document.getElementById('startTimeHandle');
        const endTimeHandle = document.getElementById('endTimeHandle');
        const timeSliderSelection = document.getElementById('timeSliderSelection');
        const startTimeLabel = document.getElementById('startTimeLabel');
        const endTimeLabel = document.getElementById('endTimeLabel');
        const currentTime = document.getElementById('currentTime');
        const totalTime = document.getElementById('totalTime');
        const rotateLargeLeft = document.getElementById('rotateLargeLeft');
        const rotateLargeRight = document.getElementById('rotateLargeRight');
        const rotateLeft = document.getElementById('rotateLeft');
        const rotateRight = document.getElementById('rotateRight');
        const rotationAngleInput = document.getElementById('rotationAngleInput');

        const analysisVideoContainer = document.getElementById('analysisVideoContainer');
        const videoPlayer = document.getElementById('videoPlayer');
        const trackingOverlay = document.getElementById('trackingOverlay');
        const skeletonOverlay = document.getElementById('skeletonOverlay');
        const angleOverlay = document.getElementById('angleOverlay');
        const pointSelector = document.getElementById('pointSelector');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const analysisProgress = document.getElementById('analysisProgress');

        const playPauseBtn = document.getElementById('playPauseBtn');
        const prevFrameBtn = document.getElementById('prevFrameBtn');
        const nextFrameBtn = document.getElementById('nextFrameBtn');
        const decreaseSpeedBtn = document.getElementById('decreaseSpeedBtn');
        const increaseSpeedBtn = document.getElementById('increaseSpeedBtn');
        const speedValue = document.getElementById('speedValue');

        const selectTrackPoint = document.getElementById('selectTrackPoint');
        const trackBarbell = document.getElementById('trackBarbell');
        const stopTracking = document.getElementById('stopTracking');
        const resetTracking = document.getElementById('resetTracking');
        const toggleSkeleton = document.getElementById('toggleSkeleton');
        const toggleAngles = document.getElementById('toggleAngles');
        const markKeyPoint = document.getElementById('markKeyPoint');
        const keyPointType = document.getElementById('keyPointType');

        const kneeAngle = document.getElementById('kneeAngle');
        const hipAngle = document.getElementById('hipAngle');
        const shoulderAngle = document.getElementById('shoulderAngle');
        const elbowAngle = document.getElementById('elbowAngle');

        const jointCheckboxes = document.querySelectorAll('.joint-checkbox');

        const trajectoryCanvas = document.getElementById('trajectoryCanvas');
        const velocityChart = document.getElementById('velocityChart');
        const powerChart = document.getElementById('powerChart');
        const displacementChart = document.getElementById('displacementChart');
        const anglesChart = document.getElementById('anglesChart');

        // 指標元素
        const maxHeight = document.getElementById('maxHeight');
        const liftEfficiency = document.getElementById('liftEfficiency');
        const firstPullTime = document.getElementById('firstPullTime');
        const secondPullTime = document.getElementById('secondPullTime');
        const powerKneeAngle = document.getElementById('powerKneeAngle');
        const powerHipAngle = document.getElementById('powerHipAngle');
        const maxVelocity = document.getElementById('maxVelocity');
        const maxPower = document.getElementById('maxPower');

        const compareVideoContainer = document.getElementById('compareVideoContainer');
        const compareVideoUpload = document.getElementById('compareVideoUpload');
        const compareContainer = document.getElementById('compareContainer');
        const compareVideoPlayer = document.getElementById('compareVideoPlayer');
        const compareOverlay = document.getElementById('compareOverlay');
        const compareSkeletonOverlay = document.getElementById('compareSkeletonOverlay');
        const compareAngleOverlay = document.getElementById('compareAngleOverlay');
        const comparePointSelector = document.getElementById('comparePointSelector');
        const compareLoadingIndicator = document.getElementById('compareLoadingIndicator');
        const compareProgress = document.getElementById('compareProgress');

        const comparePlayPauseBtn = document.getElementById('comparePlayPauseBtn');
        const comparePrevFrameBtn = document.getElementById('comparePrevFrameBtn');
        const compareNextFrameBtn = document.getElementById('compareNextFrameBtn');
        const compareDecreaseSpeedBtn = document.getElementById('compareDecreaseSpeedBtn');
        const compareIncreaseSpeedBtn = document.getElementById('compareIncreaseSpeedBtn');
        const compareSpeedValue = document.getElementById('compareSpeedValue');

        const selectCompareTrackPoint = document.getElementById('selectCompareTrackPoint');
        const trackCompare = document.getElementById('trackCompare');
        const stopCompareTracking = document.getElementById('stopCompareTracking');
        const resetCompareTracking = document.getElementById('resetCompareTracking');
        const toggleCompareSkeleton = document.getElementById('toggleCompareSkeleton');
        const toggleCompareAngles = document.getElementById('toggleCompareAngles');
        const markCompareKeyPoint = document.getElementById('markCompareKeyPoint');
        const compareKeyPointType = document.getElementById('compareKeyPointType');

        const compareKneeAngle = document.getElementById('compareKneeAngle');
        const compareHipAngle = document.getElementById('compareHipAngle');
        const compareShoulderAngle = document.getElementById('compareShoulderAngle');
        const compareElbowAngle = document.getElementById('compareElbowAngle');

        const opacitySlider = document.getElementById('opacitySlider');
        const syncPoint = document.getElementById('syncPoint');
        const syncVideos = document.getElementById('syncVideos');

        const trajectoryCompareCanvas = document.getElementById('trajectoryCompareCanvas');
        const velocityCompareChart = document.getElementById('velocityCompareChart');
        const powerCompareChart = document.getElementById('powerCompareChart');
        const displacementCompareChart = document.getElementById('displacementCompareChart');
        const anglesCompareChart = document.getElementById('anglesCompareChart');

        // 比較指標元素
        const origMaxHeight = document.getElementById('origMaxHeight');
        const origLiftEfficiency = document.getElementById('origLiftEfficiency');
        const origMaxVelocity = document.getElementById('origMaxVelocity');
        const origMaxPower = document.getElementById('origMaxPower');
        const origPowerKneeAngle = document.getElementById('origPowerKneeAngle');
        const origPowerHipAngle = document.getElementById('origPowerHipAngle');

        const compMaxHeight = document.getElementById('compMaxHeight');
        const compLiftEfficiency = document.getElementById('compLiftEfficiency');
        const compMaxVelocity = document.getElementById('compMaxVelocity');
        const compMaxPower = document.getElementById('compMaxPower');
        const compPowerKneeAngle = document.getElementById('compPowerKneeAngle');
        const compPowerHipAngle = document.getElementById('compPowerHipAngle');

        // 圖表實例
        let velocityChartInstance = null;
        let powerChartInstance = null;
        let displacementChartInstance = null;
        let anglesChartInstance = null;
        let velocityCompareChartInstance = null;
        let powerCompareChartInstance = null;
        let displacementCompareChartInstance = null;
        let anglesCompareChartInstance = null;

        // ==================== 初始化功能 ====================

        // 影片上傳處理
        videoUpload.addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file) {
                try {
                    // 建立一個檔案讀取器讀取為arraybuffer
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        // 將arraybuffer轉換為Blob
                        const blob = new Blob([e.target.result], { type: file.type });
                        // 建立URL
                        const videoURL = URL.createObjectURL(blob);

                        editVideoPlayer.src = videoURL;

                        // 保存文件引用
                        editParams.videoBlob = blob;

                        // 當元數據載入後設置時間滑塊
                        editVideoPlayer.onloadedmetadata = function () {
                            // 設置 canvas 尺寸與影片相同
                            editOverlay.width = editVideoPlayer.videoWidth;
                            editOverlay.height = editVideoPlayer.videoHeight;

                            // 初始化時間滑塊
                            initTimeSlider();
                        };

                        // 加載成功提示
                        showNotification(`已成功載入影片: ${file.name}`, 'success');
                    };
                    reader.onerror = function () {
                        console.error("檔案讀取錯誤");
                        showNotification("檔案讀取錯誤，請重試", 'error');
                    };
                    reader.readAsArrayBuffer(file);
                } catch (error) {
                    console.error("Error creating object URL:", error);
                    showNotification("無法載入視頻文件，請重試", 'error');
                }
            }
        });

        compareVideoUpload.addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file) {
                try {
                    // 建立一個檔案讀取器讀取為arraybuffer
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        // 將arraybuffer轉換為Blob
                        const blob = new Blob([e.target.result], { type: file.type });
                        // 建立URL
                        const videoURL = URL.createObjectURL(blob);

                        compareVideoPlayer.src = videoURL;
                        compareContainer.classList.remove('hidden');

                        compareVideoPlayer.onloadedmetadata = function () {
                            compareOverlay.width = compareVideoPlayer.videoWidth;
                            compareOverlay.height = compareVideoPlayer.videoHeight;
                            compareSkeletonOverlay.width = compareVideoPlayer.videoWidth;
                            compareSkeletonOverlay.height = compareVideoPlayer.videoHeight;
                        };

                        // 加載成功提示
                        showNotification(`已成功載入比較影片: ${file.name}`, 'success');
                    };
                    reader.onerror = function () {
                        console.error("比較影片檔案讀取錯誤");
                        showNotification("檔案讀取錯誤，請重試", 'error');
                    };
                    reader.readAsArrayBuffer(file);
                } catch (error) {
                    console.error("Error creating object URL for compare video:", error);
                    showNotification("無法載入比較視頻文件，請重試", 'error');
                }
            }
        });

        // 顯示通知函數
        function showNotification(message, type = 'info') {
            // 創建通知元素
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 px-6 py-3 rounded-lg shadow-lg z-50 transition transform duration-300 translate-y-0 opacity-0`;

            // 設置不同類型的樣式
            if (type === 'success') {
                notification.classList.add('bg-green-500', 'text-white');
            } else if (type === 'error') {
                notification.classList.add('bg-red-500', 'text-white');
            } else if (type === 'warning') {
                notification.classList.add('bg-yellow-500', 'text-white');
            } else {
                notification.classList.add('bg-blue-500', 'text-white');
            }

            notification.textContent = message;
            document.body.appendChild(notification);

            // 顯示動畫
            setTimeout(() => {
                notification.classList.replace('opacity-0', 'opacity-100');
                notification.classList.replace('translate-y-0', 'translate-y-1');
            }, 10);

            // 自動隱藏
            setTimeout(() => {
                notification.classList.replace('opacity-100', 'opacity-0');
                notification.classList.replace('translate-y-1', 'translate-y-0');

                // 移除元素
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // ==================== 視頻控制功能 ====================

        // 主視頻控制
        playPauseBtn.addEventListener('click', function () {
            if (videoPlayer.paused) {
                videoPlayer.play();
                this.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                                <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                            </svg>
                            暫停
                        `;
            } else {
                videoPlayer.pause();
                this.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                                <path d="M8 5v14l11-7z"/>
                            </svg>
                            播放
                        `;
            }
        });

        prevFrameBtn.addEventListener('click', function () {
            videoPlayer.pause();
            playPauseBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        播放
                    `;
            // 向後約 1/30 秒，假設是 30fps
            videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 0.033);
            updatePoseDisplay();
        });

        nextFrameBtn.addEventListener('click', function () {
            videoPlayer.pause();
            playPauseBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        播放
                    `;
            // 向前約 1/30 秒，假設是 30fps
            videoPlayer.currentTime = Math.min(videoPlayer.duration, videoPlayer.currentTime + 0.033);
            updatePoseDisplay();
        });

        decreaseSpeedBtn.addEventListener('click', function () {
            trackingParams.playbackRate = Math.max(0.1, trackingParams.playbackRate - 0.1);
            videoPlayer.playbackRate = trackingParams.playbackRate;
            speedValue.textContent = trackingParams.playbackRate.toFixed(1) + "x";
        });

        increaseSpeedBtn.addEventListener('click', function () {
            trackingParams.playbackRate = Math.min(2.0, trackingParams.playbackRate + 0.1);
            videoPlayer.playbackRate = trackingParams.playbackRate;
            speedValue.textContent = trackingParams.playbackRate.toFixed(1) + "x";
        });

        // 比較視頻控制
        comparePlayPauseBtn.addEventListener('click', function () {
            if (compareVideoPlayer.paused) {
                compareVideoPlayer.play();
                this.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                                <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                            </svg>
                            暫停
                        `;
            } else {
                compareVideoPlayer.pause();
                this.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                                <path d="M8 5v14l11-7z"/>
                            </svg>
                            播放
                        `;
            }
        });

        comparePrevFrameBtn.addEventListener('click', function () {
            compareVideoPlayer.pause();
            comparePlayPauseBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        播放
                    `;
            // 向後約 1/30 秒，假設是 30fps
            compareVideoPlayer.currentTime = Math.max(0, compareVideoPlayer.currentTime - 0.033);
            updateComparePoseDisplay();
        });

        compareNextFrameBtn.addEventListener('click', function () {
            compareVideoPlayer.pause();
            comparePlayPauseBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        播放
                    `;
            // 向前約 1/30 秒，假設是 30fps
            compareVideoPlayer.currentTime = Math.min(compareVideoPlayer.duration, compareVideoPlayer.currentTime + 0.033);
            updateComparePoseDisplay();
        });

        compareDecreaseSpeedBtn.addEventListener('click', function () {
            compareTrackingParams.playbackRate = Math.max(0.1, compareTrackingParams.playbackRate - 0.1);
            compareVideoPlayer.playbackRate = compareTrackingParams.playbackRate;
            compareSpeedValue.textContent = compareTrackingParams.playbackRate.toFixed(1) + "x";
        });

        compareIncreaseSpeedBtn.addEventListener('click', function () {
            compareTrackingParams.playbackRate = Math.min(2.0, compareTrackingParams.playbackRate + 0.1);
            compareVideoPlayer.playbackRate = compareTrackingParams.playbackRate;
            compareSpeedValue.textContent = compareTrackingParams.playbackRate.toFixed(1) + "x";
        });

        // 更新當前幀的姿勢顯示
        function updatePoseDisplay() {
            if (!trackingParams.showSkeleton || analysisData.poses.length === 0) return;

            // 找到當前時間最接近的姿勢
            const currentTime = videoPlayer.currentTime;
            let closestPose = null;
            let minTimeDiff = Infinity;

            for (let i = 0; i < analysisData.timePoints.length; i++) {
                const timeDiff = Math.abs(analysisData.timePoints[i] - currentTime);
                if (timeDiff < minTimeDiff) {
                    minTimeDiff = timeDiff;
                    if (i < analysisData.poses.length) {
                        closestPose = analysisData.poses[i];
                    }
                }
            }

            if (closestPose) {
                drawSkeleton(closestPose, skeletonOverlay, trackingParams.activeJoints);

                if (trackingParams.showAngles) {
                    updateAngleDisplay(closestPose);
                }
            }
        }

        // 更新比較影片的姿勢顯示
        function updateComparePoseDisplay() {
            if (!compareTrackingParams.showSkeleton || compareData.poses.length === 0) return;

            // 找到當前時間最接近的姿勢
            const currentTime = compareVideoPlayer.currentTime;
            let closestPose = null;
            let minTimeDiff = Infinity;

            for (let i = 0; i < compareData.timePoints.length; i++) {
                const timeDiff = Math.abs(compareData.timePoints[i] - currentTime);
                if (timeDiff < minTimeDiff) {
                    minTimeDiff = timeDiff;
                    if (i < compareData.poses.length) {
                        closestPose = compareData.poses[i];
                    }
                }
            }

            if (closestPose) {
                drawSkeleton(closestPose, compareSkeletonOverlay, compareTrackingParams.activeJoints);

                if (compareTrackingParams.showAngles) {
                    updateCompareAngleDisplay(closestPose);
                }
            }
        }

        // 當視頻時間更新時更新姿勢顯示
        videoPlayer.addEventListener('timeupdate', updatePoseDisplay);
        compareVideoPlayer.addEventListener('timeupdate', updateComparePoseDisplay);

        // 關節選擇器事件處理
        jointCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', function () {
                const joint = this.value;
                trackingParams.activeJoints[joint] = this.checked;
                compareTrackingParams.activeJoints[joint] = this.checked;

                // 更新顯示
                updatePoseDisplay();
                updateComparePoseDisplay();
            });
        });

        // 切換骨架顯示
        toggleSkeleton.addEventListener('click', function () {
            trackingParams.showSkeleton = !trackingParams.showSkeleton;

            if (trackingParams.showSkeleton) {
                toggleSkeleton.textContent = "隱藏骨架";

                // 如果PoseNet未準備好
                if (!poseNetReady && !poseNetAllowed) {
                    showPermissionDialog();
                    return;
                }

                // 如果有姿勢數據，顯示骨架
                if (analysisData.poses.length > 0) {
                    updatePoseDisplay();
                } else {
                    // 如果沒有姿勢數據，嘗試獲取當前幀的姿勢
                    estimatePoseForCurrentFrame();
                }
            } else {
                toggleSkeleton.textContent = "顯示骨架";
                // 清除骨架顯示
                const ctx = skeletonOverlay.getContext('2d');
                ctx.clearRect(0, 0, skeletonOverlay.width, skeletonOverlay.height);
            }
        });

        // 切換比較影片骨架顯示
        toggleCompareSkeleton.addEventListener('click', function () {
            compareTrackingParams.showSkeleton = !compareTrackingParams.showSkeleton;

            if (compareTrackingParams.showSkeleton) {
                toggleCompareSkeleton.textContent = "隱藏骨架";

                // 如果PoseNet未準備好
                if (!poseNetReady && !poseNetAllowed) {
                    showPermissionDialog();
                    return;
                }

                // 如果有姿勢數據，顯示骨架
                if (compareData.poses.length > 0) {
                    updateComparePoseDisplay();
                } else {
                    // 如果沒有姿勢數據，嘗試獲取當前幀的姿勢
                    estimateCompareFramePose();
                }
            } else {
                toggleCompareSkeleton.textContent = "顯示骨架";
                // 清除骨架顯示
                const ctx = compareSkeletonOverlay.getContext('2d');
                ctx.clearRect(0, 0, compareSkeletonOverlay.width, compareSkeletonOverlay.height);
            }
        });

        // 切換角度顯示
        toggleAngles.addEventListener('click', function () {
            trackingParams.showAngles = !trackingParams.showAngles;

            if (trackingParams.showAngles) {
                toggleAngles.textContent = "隱藏關節角度";
                angleOverlay.classList.remove('hidden');

                // 如果PoseNet未準備好
                if (!poseNetReady && !poseNetAllowed) {
                    showPermissionDialog();
                    return;
                }

                // 如果有姿勢數據，更新角度顯示
                if (analysisData.poses.length > 0) {
                    updatePoseDisplay();
                } else {
                    // 如果沒有姿勢數據，嘗試獲取當前幀的姿勢
                    estimatePoseForCurrentFrame();
                }
            } else {
                toggleAngles.textContent = "顯示關節角度";
                angleOverlay.classList.add('hidden');
            }
        });

        // 切換比較影片角度顯示
        toggleCompareAngles.addEventListener('click', function () {
            compareTrackingParams.showAngles = !compareTrackingParams.showAngles;

            if (compareTrackingParams.showAngles) {
                toggleCompareAngles.textContent = "隱藏關節角度";
                compareAngleOverlay.classList.remove('hidden');

                // 如果PoseNet未準備好
                if (!poseNetReady && !poseNetAllowed) {
                    showPermissionDialog();
                    return;
                }

                // 如果有姿勢數據，更新角度顯示
                if (compareData.poses.length > 0) {
                    updateComparePoseDisplay();
                } else {
                    // 如果沒有姿勢數據，嘗試獲取當前幀的姿勢
                    estimateCompareFramePose();
                }
            } else {
                toggleCompareAngles.textContent = "顯示關節角度";
                compareAngleOverlay.classList.add('hidden');
            }
        });

        // 為當前幀估計姿勢
        async function estimatePoseForCurrentFrame() {
            if (!poseNetReady || !poseNetModel) {
                console.error("PoseNet 還未準備好");
                showNotification("骨架分析模型尚未準備好，請先允許權限", "warning");
                return;
            }

            try {
                // 顯示加載指示
                showNotification("正在分析骨架...", "info");

                // 將當前影片幀繪製到 canvas 上
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = videoPlayer.videoWidth;
                canvas.height = videoPlayer.videoHeight;
                ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);

                // 使用 PoseNet 檢測姿勢
                const pose = await poseNetModel.estimateSinglePose(canvas, {
                    flipHorizontal: false
                });

                // 繪製骨架
                if (trackingParams.showSkeleton) {
                    drawSkeleton(pose, skeletonOverlay, trackingParams.activeJoints);
                }

                // 更新角度顯示
                if (trackingParams.showAngles) {
                    updateAngleDisplay(pose);
                }

                showNotification("骨架分析完成", "success");
            } catch (error) {
                console.error("姿勢估計錯誤:", error);
                showNotification("骨架分析失敗，請重試", "error");
            }
        }

        // 為比較影片當前幀估計姿勢
        async function estimateCompareFramePose() {
            if (!poseNetReady || !poseNetModel) {
                console.error("PoseNet 還未準備好");
                showNotification("骨架分析模型尚未準備好，請先允許權限", "warning");
                return;
            }

            try {
                // 顯示加載指示
                showNotification("正在分析比較影片骨架...", "info");

                // 將當前影片幀繪製到 canvas 上
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = compareVideoPlayer.videoWidth;
                canvas.height = compareVideoPlayer.videoHeight;
                ctx.drawImage(compareVideoPlayer, 0, 0, canvas.width, canvas.height);

                // 使用 PoseNet 檢測姿勢
                const pose = await poseNetModel.estimateSinglePose(canvas, {
                    flipHorizontal: false
                });

                // 繪製骨架
                if (compareTrackingParams.showSkeleton) {
                    drawSkeleton(pose, compareSkeletonOverlay, compareTrackingParams.activeJoints);
                }

                // 更新角度顯示
                if (compareTrackingParams.showAngles) {
                    updateCompareAngleDisplay(pose);
                }

                showNotification("比較影片骨架分析完成", "success");
            } catch (error) {
                console.error("比較影片姿勢估計錯誤:", error);
                showNotification("骨架分析失敗，請重試", "error");
            }
        }

        // 更新角度顯示
        function updateAngleDisplay(pose) {
            // 計算膝關節角度
            const kneeJointAngle = calculateJointAngle(pose, 'leftHip', 'leftKnee', 'leftAnkle') ||
                calculateJointAngle(pose, 'rightHip', 'rightKnee', 'rightAnkle');

            // 計算髖關節角度
            const hipJointAngle = calculateJointAngle(pose, 'leftShoulder', 'leftHip', 'leftKnee') ||
                calculateJointAngle(pose, 'rightShoulder', 'rightHip', 'rightKnee');

            // 計算肩關節角度
            const shoulderJointAngle = calculateJointAngle(pose, 'leftElbow', 'leftShoulder', 'leftHip') ||
                calculateJointAngle(pose, 'rightElbow', 'rightShoulder', 'rightHip');

            // 計算肘關節角度
            const elbowJointAngle = calculateJointAngle(pose, 'leftWrist', 'leftElbow', 'leftShoulder') ||
                calculateJointAngle(pose, 'rightWrist', 'rightElbow', 'rightShoulder');

            // 更新顯示
            kneeAngle.textContent = kneeJointAngle ? kneeJointAngle.toFixed(1) : "-";
            hipAngle.textContent = hipJointAngle ? hipJointAngle.toFixed(1) : "-";
            shoulderAngle.textContent = shoulderJointAngle ? shoulderJointAngle.toFixed(1) : "-";
            elbowAngle.textContent = elbowJointAngle ? elbowJointAngle.toFixed(1) : "-";
        }

        // 更新比較影片角度顯示
        function updateCompareAngleDisplay(pose) {
            // 計算膝關節角度
            const kneeJointAngle = calculateJointAngle(pose, 'leftHip', 'leftKnee', 'leftAnkle') ||
                calculateJointAngle(pose, 'rightHip', 'rightKnee', 'rightAnkle');

            // 計算髖關節角度
            const hipJointAngle = calculateJointAngle(pose, 'leftShoulder', 'leftHip', 'leftKnee') ||
                calculateJointAngle(pose, 'rightShoulder', 'rightHip', 'rightKnee');

            // 計算肩關節角度
            const shoulderJointAngle = calculateJointAngle(pose, 'leftElbow', 'leftShoulder', 'leftHip') ||
                calculateJointAngle(pose, 'rightElbow', 'rightShoulder', 'rightHip');

            // 計算肘關節角度
            const elbowJointAngle = calculateJointAngle(pose, 'leftWrist', 'leftElbow', 'leftShoulder') ||
                calculateJointAngle(pose, 'rightWrist', 'rightElbow', 'rightShoulder');

            // 更新顯示
            compareKneeAngle.textContent = kneeJointAngle ? kneeJointAngle.toFixed(1) : "-";
            compareHipAngle.textContent = hipJointAngle ? hipJointAngle.toFixed(1) : "-";
            compareShoulderAngle.textContent = shoulderJointAngle ? shoulderJointAngle.toFixed(1) : "-";
            compareElbowAngle.textContent = elbowJointAngle ? elbowJointAngle.toFixed(1) : "-";
        }

        // 計算關節角度
        function calculateJointAngle(pose, upperJoint, midJoint, lowerJoint) {
            // 獲取關節位置
            const upperPoint = getJointPosition(pose, upperJoint);
            const midPoint = getJointPosition(pose, midJoint);
            const lowerPoint = getJointPosition(pose, lowerJoint);

            if (!upperPoint || !midPoint || !lowerPoint) return null;

            // 計算向量
            const vector1 = {
                x: upperPoint.x - midPoint.x,
                y: upperPoint.y - midPoint.y
            };

            const vector2 = {
                x: lowerPoint.x - midPoint.x,
                y: lowerPoint.y - midPoint.y
            };

            // 計算角度
            const dotProduct = vector1.x * vector2.x + vector1.y * vector2.y;
            const magnitude1 = Math.sqrt(vector1.x * vector1.x + vector1.y * vector1.y);
            const magnitude2 = Math.sqrt(vector2.x * vector2.x + vector2.y * vector2.y);

            if (magnitude1 === 0 || magnitude2 === 0) return null;

            const cosAngle = dotProduct / (magnitude1 * magnitude2);

            // 確保 cosAngle 在 -1 到 1 之間
            const clampedCosAngle = Math.max(-1, Math.min(1, cosAngle));

            // 轉換為角度 (度)
            const angleInRadians = Math.acos(clampedCosAngle);
            const angleInDegrees = angleInRadians * (180 / Math.PI);

            return angleInDegrees;
        }

        // 從姿勢數據中獲取關節位置
        function getJointPosition(pose, jointName) {
            const keypoint = pose.keypoints.find(kp => kp.part === jointName);

            if (keypoint && keypoint.score > 0.2) {
                return { x: keypoint.position.x, y: keypoint.position.y };
            }

            return null;
        }

        // 繪製骨架
        function drawSkeleton(pose, canvas, activeJoints) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 定義骨架連接
            const pairs = [
                ['leftShoulder', 'rightShoulder'],
                ['leftShoulder', 'leftElbow'],
                ['leftElbow', 'leftWrist'],
                ['rightShoulder', 'rightElbow'],
                ['rightElbow', 'rightWrist'],
                ['leftShoulder', 'leftHip'],
                ['rightShoulder', 'rightHip'],
                ['leftHip', 'rightHip'],
                ['leftHip', 'leftKnee'],
                ['leftKnee', 'leftAnkle'],
                ['rightHip', 'rightKnee'],
                ['rightKnee', 'rightAnkle']
            ];

            // 繪製骨架線條
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'lime';
            ctx.shadowColor = 'rgba(0, 255, 0, 0.5)';
            ctx.shadowBlur = 5;

            pairs.forEach(pair => {
                const jointA = pair[0];
                const jointB = pair[1];

                // 檢查是否需要顯示這個關節
                const shouldShowJoint = (
                    (jointA.includes('Knee') || jointB.includes('Knee')) && activeJoints.knee ||
                    (jointA.includes('Hip') || jointB.includes('Hip')) && activeJoints.hip ||
                    (jointA.includes('Shoulder') || jointB.includes('Shoulder')) && activeJoints.shoulder ||
                    (jointA.includes('Elbow') || jointB.includes('Elbow')) && activeJoints.elbow ||
                    (jointA.includes('Ankle') || jointB.includes('Ankle')) && activeJoints.ankle ||
                    (jointA.includes('Wrist') || jointB.includes('Wrist')) && activeJoints.wrist
                );

                if (!shouldShowJoint) return;

                const pointA = getJointPosition(pose, jointA);
                const pointB = getJointPosition(pose, jointB);

                if (pointA && pointB) {
                    ctx.beginPath();
                    ctx.moveTo(pointA.x, pointA.y);
                    ctx.lineTo(pointB.x, pointB.y);
                    ctx.stroke();
                }
            });

            // 繪製關節點
            ctx.fillStyle = 'red';
            ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
            ctx.shadowBlur = 8;

            pose.keypoints.forEach(keypoint => {
                if (keypoint.score > 0.2) {
                    // 檢查是否需要顯示這個關節
                    const shouldShowJoint = (
                        keypoint.part.includes('Knee') && activeJoints.knee ||
                        keypoint.part.includes('Hip') && activeJoints.hip ||
                        keypoint.part.includes('Shoulder') && activeJoints.shoulder ||
                        keypoint.part.includes('Elbow') && activeJoints.elbow ||
                        keypoint.part.includes('Ankle') && activeJoints.ankle ||
                        keypoint.part.includes('Wrist') && activeJoints.wrist
                    );

                    if (shouldShowJoint) {
                        ctx.beginPath();
                        ctx.arc(keypoint.position.x, keypoint.position.y, 5, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
            });

            // 如果啟用了角度顯示，繪製角度標記
            if (activeJoints.knee) {
                drawAngleMarker(pose, ctx, 'leftHip', 'leftKnee', 'leftAnkle', 'knee');
                drawAngleMarker(pose, ctx, 'rightHip', 'rightKnee', 'rightAnkle', 'knee');
            }

            if (activeJoints.hip) {
                drawAngleMarker(pose, ctx, 'leftShoulder', 'leftHip', 'leftKnee', 'hip');
                drawAngleMarker(pose, ctx, 'rightShoulder', 'rightHip', 'rightKnee', 'hip');
            }

            if (activeJoints.shoulder) {
                drawAngleMarker(pose, ctx, 'leftElbow', 'leftShoulder', 'leftHip', 'shoulder');
                drawAngleMarker(pose, ctx, 'rightElbow', 'rightShoulder', 'rightHip', 'shoulder');
            }

            if (activeJoints.elbow) {
                drawAngleMarker(pose, ctx, 'leftWrist', 'leftElbow', 'leftShoulder', 'elbow');
                drawAngleMarker(pose, ctx, 'rightWrist', 'rightElbow', 'rightShoulder', 'elbow');
            }
        }

        // 繪製角度標記
        function drawAngleMarker(pose, ctx, upperJoint, midJoint, lowerJoint, jointType) {
            const upperPoint = getJointPosition(pose, upperJoint);
            const midPoint = getJointPosition(pose, midJoint);
            const lowerPoint = getJointPosition(pose, lowerJoint);

            if (!upperPoint || !midPoint || !lowerPoint) return;

            // 計算角度
            const angle = calculateJointAngle(pose, upperJoint, midJoint, lowerJoint);
            if (angle === null) return;

            // 根據關節類型設置顏色
            let color;
            switch (jointType) {
                case 'knee': color = 'rgba(255, 0, 0, 0.7)'; break;
                case 'hip': color = 'rgba(0, 255, 0, 0.7)'; break;
                case 'shoulder': color = 'rgba(0, 0, 255, 0.7)'; break;
                case 'elbow': color = 'rgba(255, 255, 0, 0.7)'; break;
                default: color = 'rgba(255, 255, 255, 0.7)';
            }

            // 繪製角度弧
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(midPoint.x, midPoint.y);
            ctx.arc(midPoint.x, midPoint.y, 25,
                Math.atan2(upperPoint.y - midPoint.y, upperPoint.x - midPoint.x),
                Math.atan2(lowerPoint.y - midPoint.y, lowerPoint.x - midPoint.x),
                false);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.3;
            ctx.fill();
            ctx.globalAlpha = 1.0;

            // 繪製角度文字
            ctx.font = '14px Arial';
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // 計算文字位置（角度弧的中間點向外延伸）
            const textAngle = (Math.atan2(upperPoint.y - midPoint.y, upperPoint.x - midPoint.x) +
                Math.atan2(lowerPoint.y - midPoint.y, lowerPoint.x - midPoint.x)) / 2;

            const textX = midPoint.x + Math.cos(textAngle) * 45;
            const textY = midPoint.y + Math.sin(textAngle) * 45;

            const angleText = `${angle.toFixed(0)}°`;
            ctx.strokeText(angleText, textX, textY);
            ctx.fillText(angleText, textX, textY);
            ctx.restore();
        }

        // ==================== 編輯功能實現 ====================

        // 預覽和編輯按鈕
        startEditingBtn.addEventListener('click', function () {
            if (!editVideoPlayer.src) {
                showNotification('請先上傳影片', 'warning');
                return;
            }

            editingSection.classList.remove('hidden');
            analysisSection.classList.add('hidden');
        });

        // 初始化時間滑塊
        function initTimeSlider() {
            const duration = editVideoPlayer.duration;

            // 初始化起始和結束時間
            editParams.startTime = 0;
            editParams.endTime = duration;

            // 設置顯示
            startTimeLabel.textContent = formatTime(0);
            endTimeLabel.textContent = formatTime(duration);
            totalTime.textContent = `總時長: ${formatTime(duration)}`;

            // 設置滑塊位置
            positionTimeHandles();

            // 設置滑塊選擇區域
            updateTimeSelection();

            // 添加拖動滑塊的事件處理
            setupDragHandles();

            // 更新當前時間顯示
            editVideoPlayer.addEventListener('timeupdate', function () {
                currentTime.textContent = `當前時間: ${formatTime(editVideoPlayer.currentTime)}`;
            });
        }

        // 格式化時間顯示 (秒 -> mm:ss)
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // 設置滑塊位置
        function positionTimeHandles() {
            const track = document.querySelector('.slider-track');
            const trackRect = track.getBoundingClientRect();
            const trackWidth = trackRect.width;

            const duration = editVideoPlayer.duration;
            const startPercent = (editParams.startTime / duration) * 100;
            const endPercent = (editParams.endTime / duration) * 100;

            // 設置滑塊位置
            startTimeHandle.style.left = `${startPercent}%`;
            endTimeHandle.style.left = `${endPercent}%`;

            // 更新時間標籤位置
            startTimeLabel.style.left = `${startPercent}%`;
            endTimeLabel.style.left = `${endPercent}%`;
        }

        // 更新時間選擇區域
        function updateTimeSelection() {
            const duration = editVideoPlayer.duration;
            const startPercent = (editParams.startTime / duration) * 100;
            const endPercent = (editParams.endTime / duration) * 100;

            timeSliderSelection.style.left = `${startPercent}%`;
            timeSliderSelection.style.width = `${endPercent - startPercent}%`;
        }

        // 設置滑塊拖動功能
        function setupDragHandles() {
            let isDraggingStart = false;
            let isDraggingEnd = false;

            // 滑鼠按下
            startTimeHandle.addEventListener('mousedown', function (e) {
                isDraggingStart = true;
                e.preventDefault();
            });

            endTimeHandle.addEventListener('mousedown', function (e) {
                isDraggingEnd = true;
                e.preventDefault();
            });

            // 滑鼠移動
            document.addEventListener('mousemove', function (e) {
                if (!isDraggingStart && !isDraggingEnd) return;

                const track = document.querySelector('.slider-track');
                const trackRect = track.getBoundingClientRect();
                const trackWidth = trackRect.width;
                const clickX = e.clientX - trackRect.left;
                const duration = editVideoPlayer.duration;

                // 計算時間位置 (0-1 範圍)
                let percent = Math.max(0, Math.min(1, clickX / trackWidth));
                let time = percent * duration;

                if (isDraggingStart) {
                    // 確保起始時間不超過結束時間
                    editParams.startTime = Math.min(time, editParams.endTime - 0.5);
                    startTimeLabel.textContent = formatTime(editParams.startTime);

                    // 設置影片當前時間
                    editVideoPlayer.currentTime = editParams.startTime;
                } else if (isDraggingEnd) {
                    // 確保結束時間不小於起始時間
                    editParams.endTime = Math.max(time, editParams.startTime + 0.5);
                    endTimeLabel.textContent = formatTime(editParams.endTime);

                    // 設置影片當前時間
                    editVideoPlayer.currentTime = editParams.endTime;
                }

                // 更新滑塊位置和選擇區域
                positionTimeHandles();
                updateTimeSelection();
            });

            // 觸控支持
            startTimeHandle.addEventListener('touchstart', function (e) {
                isDraggingStart = true;
                e.preventDefault();
            });

            endTimeHandle.addEventListener('touchstart', function (e) {
                isDraggingEnd = true;
                e.preventDefault();
            });

            // 觸控移動
            document.addEventListener('touchmove', function (e) {
                if (!isDraggingStart && !isDraggingEnd) return;

                const touch = e.touches[0];
                const track = document.querySelector('.slider-track');
                const trackRect = track.getBoundingClientRect();
                const trackWidth = trackRect.width;
                const clickX = touch.clientX - trackRect.left;
                const duration = editVideoPlayer.duration;

                // 計算時間位置
                let percent = Math.max(0, Math.min(1, clickX / trackWidth));
                let time = percent * duration;

                if (isDraggingStart) {
                    // 確保起始時間不超過結束時間
                    editParams.startTime = Math.min(time, editParams.endTime - 0.5);
                    startTimeLabel.textContent = formatTime(editParams.startTime);

                    // 設置影片當前時間
                    editVideoPlayer.currentTime = editParams.startTime;
                } else if (isDraggingEnd) {
                    // 確保結束時間不小於起始時間
                    editParams.endTime = Math.max(time, editParams.startTime + 0.5);
                    endTimeLabel.textContent = formatTime(editParams.endTime);

                    // 設置影片當前時間
                    editVideoPlayer.currentTime = editParams.endTime;
                }

                // 更新滑塊位置和選擇區域
                positionTimeHandles();
                updateTimeSelection();
            });

            // 滑鼠釋放
            document.addEventListener('mouseup', function () {
                isDraggingStart = false;
                isDraggingEnd = false;
            });

            // 觸控結束
            document.addEventListener('touchend', function () {
                isDraggingStart = false;
                isDraggingEnd = false;
            });
        }

        // 旋轉按鈕事件監聽
        rotateLargeLeft.addEventListener('click', function () {
            editParams.rotationAngle = (editParams.rotationAngle - 90) % 360;
            updateRotationDisplay();
        });

        rotateLargeRight.addEventListener('click', function () {
            editParams.rotationAngle = (editParams.rotationAngle + 90) % 360;
            updateRotationDisplay();
        });

        rotateLeft.addEventListener('click', function () {
            editParams.rotationAngle = (editParams.rotationAngle - 1) % 360;
            updateRotationDisplay();
        });

        rotateRight.addEventListener('click', function () {
            editParams.rotationAngle = (editParams.rotationAngle + 1) % 360;
            updateRotationDisplay();
        });

        // 旋轉角度輸入框處理
        rotationAngleInput.addEventListener('input', function () {
            let angle = parseInt(this.value) || 0;
            // 限制在-180到180度之間
            angle = Math.max(-180, Math.min(180, angle));
            editParams.rotationAngle = angle;

            // 更新輸入框
            this.value = angle;

            // 更新顯示
            updateRotationDisplay();
        });

        // 更新旋轉角度顯示
        function updateRotationDisplay() {
            rotationAngleInput.value = editParams.rotationAngle;

            // 旋轉預覽影片和容器
            updateVideoRotation(videoContainer, editVideoPlayer, editOverlay, editParams.rotationAngle);
        }

        // 更新視頻旋轉
        function updateVideoRotation(container, video, overlay, angle) {
            // 旋轉影片和疊加層
            video.style.transform = `rotate(${angle}deg)`;
            overlay.style.transform = `rotate(${angle}deg)`;

            // 根據旋轉角度調整容器尺寸
            if (Math.abs(angle % 180) == 90) {
                // 對於90度或270度旋轉，我們需要調整容器尺寸
                const aspectRatio = video.videoHeight / video.videoWidth;
                container.style.paddingBottom = `${(1 / aspectRatio) * 100}%`;

                // 在視窗大小改變時也調整
                window.addEventListener('resize', function () {
                    adjustRotatedContainer(container, video, angle);
                });

                // 立即調整一次
                adjustRotatedContainer(container, video, angle);
            } else {
                // 對於0度或180度，使用原始尺寸
                container.style.paddingBottom = '';
                container.style.height = '';
                container.style.width = '';
            }
        }

        // 調整旋轉後的容器
        function adjustRotatedContainer(container, video, angle) {
            if (Math.abs(angle % 180) == 90) {
                // 對於90度或270度旋轉
                const containerWidth = container.clientWidth;
                const aspectRatio = video.videoHeight / video.videoWidth;
                const newHeight = containerWidth * aspectRatio;

                container.style.height = `${newHeight}px`;
            }
        }

        // 取消編輯
        cancelEditBtn.addEventListener('click', function () {
            editingSection.classList.add('hidden');

            // 重置編輯參數
            editParams.startTime = 0;
            editParams.endTime = editVideoPlayer.duration;
            editParams.rotationAngle = 0;

            // 重置顯示
            editVideoPlayer.style.transform = 'rotate(0deg)';
            editOverlay.style.transform = 'rotate(0deg)';
            videoContainer.style.paddingBottom = '';
            videoContainer.style.height = '';
            videoContainer.style.width = '';
            rotationAngleInput.value = "0";
        });

        // 應用編輯更改並開始分析
        applyEditBtn.addEventListener('click', function () {
            if (!editVideoPlayer.src) {
                showNotification('請先上傳影片', 'warning');
                return;
            }

            // 隱藏編輯部分，顯示分析部分
            editingSection.classList.add('hidden');
            analysisSection.classList.remove('hidden');

            // 顯示處理提示
            showNotification("正在處理影片...", "info");

            // 裁剪視頻並應用旋轉
            processVideo();
        });

        // 處理視頻
        function processVideo() {
            // 顯示加載指示器
            loadingIndicator.classList.remove('hidden');
            loadingIndicator.textContent = "處理影片中...";

            try {
                // 從原始Blob創建視頻URL
                const videoURL = URL.createObjectURL(editParams.videoBlob);

                // 設置視頻源
                videoPlayer.src = videoURL;

                // 設置分析容器尺寸
                const container = analysisVideoContainer;

                // 當視頻元數據加載完成後
                videoPlayer.onloadedmetadata = function () {
                    // 設置Canvas尺寸
                    trackingOverlay.width = videoPlayer.videoWidth;
                    trackingOverlay.height = videoPlayer.videoHeight;
                    skeletonOverlay.width = videoPlayer.videoWidth;
                    skeletonOverlay.height = videoPlayer.videoHeight;

                    // 應用旋轉
                    if (editParams.rotationAngle !== 0) {
                        updateVideoRotation(container, videoPlayer, trackingOverlay, editParams.rotationAngle);
                        skeletonOverlay.style.transform = `rotate(${editParams.rotationAngle}deg)`;
                    }

                    // 設置視頻開始時間
                    videoPlayer.currentTime = editParams.startTime;

                    // 添加時間更新處理器，確保視頻在結束時間停止
                    videoPlayer.addEventListener('timeupdate', function timeEndHandler() {
                        if (videoPlayer.currentTime >= editParams.endTime) {
                            videoPlayer.pause();
                            // 防止影片自動播放超過結束時間
                            if (videoPlayer.currentTime > editParams.endTime) {
                                videoPlayer.currentTime = editParams.endTime;
                            }
                        }
                    });

                    // 隱藏加載指示器
                    loadingIndicator.classList.add('hidden');

                    // 更新 UI 狀態
                    trackBarbell.disabled = false;
                    selectTrackPoint.disabled = false;

                    // 成功提示
                    showNotification("影片處理完成", "success");
                };

                // 初始化事件監聽並開始加載視頻
                videoPlayer.load();
            } catch (error) {
                console.error("處理視頻時出錯:", error);
                loadingIndicator.classList.add('hidden');
                showNotification("處理視頻時出錯，請重試", "error");
            }
        }

        // ==================== 槓鈴追蹤功能 ====================

        // 選擇追蹤點按鈕
        selectTrackPoint.addEventListener('click', function () {
            if (!videoPlayer.src) {
                showNotification('請先上傳並處理影片', 'warning');
                return;
            }

            // 顯示點選擇器
            pointSelector.style.display = 'block';
            trackingParams.isPointSelected = false;

            // 顯示提示
            showNotification("請點擊視頻中要追蹤的槓鈴位置", "info");
        });

        selectCompareTrackPoint.addEventListener('click', function () {
            if (!compareVideoPlayer.src) {
                showNotification('請先上傳比較影片', 'warning');
                return;
            }

            // 顯示點選擇器
            comparePointSelector.style.display = 'block';
            compareTrackingParams.isPointSelected = false;

            // 顯示提示
            showNotification("請點擊比較視頻中要追蹤的槓鈴位置", "info");
        });

        // 點擊視頻來選擇追蹤點
        videoPlayer.addEventListener('click', function (e) {
            if (pointSelector.style.display === 'block') {
                const rect = videoPlayer.getBoundingClientRect();
                const scaleX = videoPlayer.videoWidth / rect.width;
                const scaleY = videoPlayer.videoHeight / rect.height;

                // 計算點擊位置
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                // 保存追蹤點
                trackingParams.trackPoint = { x, y };
                trackingParams.isPointSelected = true;

                // 更新顯示
                pointSelector.style.left = `${e.clientX}px`;
                pointSelector.style.top = `${e.clientY}px`;

                // 閃爍點選擇器
                const flash = () => {
                    pointSelector.style.opacity = '0';
                    setTimeout(() => {
                        pointSelector.style.opacity = '1';
                        setTimeout(() => {
                            pointSelector.style.opacity = '0';
                            setTimeout(() => {
                                pointSelector.style.opacity = '1';
                                setTimeout(() => {
                                    pointSelector.style.display = 'none';
                                }, 300);
                            }, 200);
                        }, 200);
                    }, 200);
                };
                flash();

                // 顯示所選點
                const ctx = trackingOverlay.getContext('2d');
                ctx.clearRect(0, 0, trackingOverlay.width, trackingOverlay.height);

                // 使用漸變和陰影使其更漂亮
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);

                // 建立漸變
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, 12);
                gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 0, 0.2)');

                ctx.fillStyle = gradient;
                ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                ctx.shadowBlur = 15;
                ctx.fill();

                // 標記中心點
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'yellow';
                ctx.fill();

                // 顯示標記關鍵點按鈕
                markKeyPoint.classList.remove('hidden');
                keyPointType.classList.remove('hidden');

                // 顯示成功信息
                showNotification("已選擇追蹤點", "success");
            }
        });

        compareVideoPlayer.addEventListener('click', function (e) {
            if (comparePointSelector.style.display === 'block') {
                const rect = compareVideoPlayer.getBoundingClientRect();
                const scaleX = compareVideoPlayer.videoWidth / rect.width;
                const scaleY = compareVideoPlayer.videoHeight / rect.height;

                // 計算點擊位置
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                // 保存追蹤點
                compareTrackingParams.trackPoint = { x, y };
                compareTrackingParams.isPointSelected = true;

                // 更新顯示
                comparePointSelector.style.left = `${e.clientX}px`;
                comparePointSelector.style.top = `${e.clientY}px`;

                // 閃爍點選擇器
                const flash = () => {
                    comparePointSelector.style.opacity = '0';
                    setTimeout(() => {
                        comparePointSelector.style.opacity = '1';
                        setTimeout(() => {
                            comparePointSelector.style.opacity = '0';
                            setTimeout(() => {
                                comparePointSelector.style.opacity = '1';
                                setTimeout(() => {
                                    comparePointSelector.style.display = 'none';
                                }, 300);
                            }, 200);
                        }, 200);
                    }, 200);
                };
                flash();

                // 顯示所選點
                const ctx = compareOverlay.getContext('2d');
                ctx.clearRect(0, 0, compareOverlay.width, compareOverlay.height);

                // 使用漸變和陰影使其更漂亮
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);

                // 建立漸變
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, 12);
                gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 0, 0.2)');

                ctx.fillStyle = gradient;
                ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                ctx.shadowBlur = 15;
                ctx.fill();

                // 標記中心點
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'yellow';
                ctx.fill();

                // 顯示標記關鍵點按鈕
                markCompareKeyPoint.classList.remove('hidden');
                compareKeyPointType.classList.remove('hidden');

                // 顯示成功信息
                showNotification("已選擇比較影片追蹤點", "success");
            }
        });

        // 開始追蹤槓鈴
        trackBarbell.addEventListener('click', function () {
            if (!videoPlayer.src) {
                showNotification('請先上傳影片', 'warning');
                return;
            }

            if (!trackingParams.isPointSelected) {
                showNotification('請先選擇要追蹤的槓鈴位置', 'warning');
                return;
            }

            if (!opencvReady) {
                showNotification('OpenCV.js 尚未準備好，請稍候...', 'warning');
                return;
            }

            // 開始或停止追蹤
            trackingParams.isTracking = true;
            trackingParams.currentFrameIndex = 0;

            // 更新 UI
            trackBarbell.classList.add('hidden');
            stopTracking.classList.remove('hidden');
            loadingIndicator.classList.remove('hidden');
            loadingIndicator.textContent = "處理中...";
            analysisProgress.style.width = "0%";

            // 清空之前的數據
            analysisData.trajectoryPoints = [];
            analysisData.velocityData = [];
            analysisData.powerData = [];
            analysisData.displacementData = [];
            analysisData.timePoints = [];
            analysisData.poses = [];
            analysisData.angles = {
                knee: [],
                hip: [],
                shoulder: [],
                elbow: []
            };

            // 準備影片以進行逐幀處理
            videoPlayer.currentTime = editParams.startTime;
            videoPlayer.pause();

            // 顯示開始追蹤消息
            showNotification("開始槓鈴追蹤...", "info");

            // 初始化顏色範圍 - 我們會在第一幀中計算它
            calculateColorRange(videoPlayer, trackingParams, () => {
                // 開始追蹤
                trackFrame();
            });
        });

        trackCompare.addEventListener('click', function () {
            if (!compareVideoPlayer.src) {
                showNotification('請先上傳比較影片', 'warning');
                return;
            }

            if (!compareTrackingParams.isPointSelected) {
                showNotification('請先選擇要追蹤的槓鈴位置', 'warning');
                return;
            }

            if (!opencvReady) {
                showNotification('OpenCV.js 尚未準備好，請稍候...', 'warning');
                return;
            }

            // 開始或停止追蹤
            compareTrackingParams.isTracking = true;
            compareTrackingParams.currentFrameIndex = 0;

            // 更新 UI
            trackCompare.classList.add('hidden');
            stopCompareTracking.classList.remove('hidden');
            compareLoadingIndicator.classList.remove('hidden');
            compareLoadingIndicator.textContent = "處理中...";
            compareProgress.style.width = "0%";

            // 清空之前的數據
            compareData.trajectoryPoints = [];
            compareData.velocityData = [];
            compareData.powerData = [];
            compareData.displacementData = [];
            compareData.timePoints = [];
            compareData.poses = [];
            compareData.angles = {
                knee: [],
                hip: [],
                shoulder: [],
                elbow: []
            };

            // 準備影片以進行逐幀處理
            compareVideoPlayer.currentTime = 0;
            compareVideoPlayer.pause();

            // 顯示開始追蹤消息
            showNotification("開始比較影片槓鈴追蹤...", "info");

            // 初始化顏色範圍
            calculateColorRange(compareVideoPlayer, compareTrackingParams, () => {
                // 開始追蹤
                trackCompareFrame();
            });
        });

        // 計算顏色範圍
        function calculateColorRange(videoElem, params, callback) {
            if (!opencvReady) {
                console.error("OpenCV 尚未準備好");
                showNotification("OpenCV 尚未準備好，請重試", "error");
                return;
            }

            try {
                // 建立一個臨時 canvas 來處理視頻幀
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = videoElem.videoWidth;
                canvas.height = videoElem.videoHeight;

                // 繪製當前視頻幀
                ctx.drawImage(videoElem, 0, 0, canvas.width, canvas.height);

                // 獲取像素數據
                const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // 轉換為 OpenCV Mat
                const src = cv.matFromImageData(imgData);

                // 計算感興趣區域 (ROI)
                const x = Math.max(0, Math.floor(params.trackPoint.x - 15));
                const y = Math.max(0, Math.floor(params.trackPoint.y - 15));
                const width = Math.min(30, canvas.width - x);
                const height = Math.min(30, canvas.height - y);

                const roi = src.roi(new cv.Rect(x, y, width, height));

                // 轉換為 HSV 顏色空間
                const hsv = new cv.Mat();
                cv.cvtColor(roi, hsv, cv.COLOR_RGBA2RGB);
                cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);

                // 計算 ROI 中的平均 HSV 值
                const mean = cv.mean(hsv);

                // 設定 HSV 範圍（加減一定的容差）
                const h_tolerance = 20;
                const s_tolerance = 70;
                const v_tolerance = 70;

                params.HSV_min = [
                    Math.max(0, mean[0] - h_tolerance),
                    Math.max(0, mean[1] - s_tolerance),
                    Math.max(0, mean[2] - v_tolerance)
                ];

                params.HSV_max = [
                    Math.min(180, mean[0] + h_tolerance),
                    Math.min(255, mean[1] + s_tolerance),
                    Math.min(255, mean[2] + v_tolerance)
                ];

                // 釋放 OpenCV 資源
                src.delete();
                roi.delete();
                hsv.delete();

                callback();
            } catch (error) {
                console.error("計算顏色範圍錯誤:", error);
                showNotification("計算顏色範圍時發生錯誤，請重試", "error");
            }
        }

        // 追蹤單個幀
        async function trackFrame() {
            if (!trackingParams.isTracking) return;

            // 檢查是否到達視頻結尾或編輯結束時間
            if (videoPlayer.currentTime >= editParams.endTime) {
                finishTracking();
                return;
            }

            try {
                // 建立一個臨時 canvas 來處理視頻幀
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = videoPlayer.videoWidth;
                canvas.height = videoPlayer.videoHeight;

                // 繪製當前視頻幀
                ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);

                // 追蹤當前幀中的槓鈴
                const trackResult = trackBarbellInFrame(canvas, trackingParams);

                // 估計骨架姿勢
                let poseResult = null;
                if (poseNetReady && poseNetModel && poseNetAllowed) {
                    try {
                        poseResult = await poseNetModel.estimateSinglePose(canvas, {
                            flipHorizontal: false
                        });

                        // 計算關節角度
                        const kneeJointAngle = calculateJointAngle(poseResult, 'leftHip', 'leftKnee', 'leftAnkle') ||
                            calculateJointAngle(poseResult, 'rightHip', 'rightKnee', 'rightAnkle');

                        const hipJointAngle = calculateJointAngle(poseResult, 'leftShoulder', 'leftHip', 'leftKnee') ||
                            calculateJointAngle(poseResult, 'rightShoulder', 'rightHip', 'rightKnee');

                        const shoulderJointAngle = calculateJointAngle(poseResult, 'leftElbow', 'leftShoulder', 'leftHip') ||
                            calculateJointAngle(poseResult, 'rightElbow', 'rightShoulder', 'rightHip');

                        const elbowJointAngle = calculateJointAngle(poseResult, 'leftWrist', 'leftElbow', 'leftShoulder') ||
                            calculateJointAngle(poseResult, 'rightWrist', 'rightElbow', 'rightShoulder');

                        // 儲存角度數據
                        if (kneeJointAngle) {
                            analysisData.angles.knee.push({
                                time: videoPlayer.currentTime,
                                value: kneeJointAngle
                            });
                        }

                        if (hipJointAngle) {
                            analysisData.angles.hip.push({
                                time: videoPlayer.currentTime,
                                value: hipJointAngle
                            });
                        }

                        if (shoulderJointAngle) {
                            analysisData.angles.shoulder.push({
                                time: videoPlayer.currentTime,
                                value: shoulderJointAngle
                            });
                        }

                        if (elbowJointAngle) {
                            analysisData.angles.elbow.push({
                                time: videoPlayer.currentTime,
                                value: elbowJointAngle
                            });
                        }

                        // 儲存姿勢
                        analysisData.poses.push(poseResult);

                        // 如果啟用了骨架顯示，繪製骨架
                        if (trackingParams.showSkeleton) {
                            drawSkeleton(poseResult, skeletonOverlay, trackingParams.activeJoints);
                        }

                        // 更新角度顯示
                        if (trackingParams.showAngles) {
                            updateAngleDisplay(poseResult);
                        }
                    } catch (error) {
                        console.error("姿勢估計錯誤:", error);
                    }
                }

                if (trackResult) {
                    // 儲存追蹤結果
                    analysisData.trajectoryPoints.push({
                        x: trackResult.x,
                        y: trackResult.y,
                        frame: trackingParams.currentFrameIndex,
                        time: videoPlayer.currentTime
                    });

                    // 儲存時間點
                    analysisData.timePoints.push(videoPlayer.currentTime);

                    // 計算速度和位移（從第二幀開始）
                    if (analysisData.trajectoryPoints.length > 1) {
                        const current = analysisData.trajectoryPoints[analysisData.trajectoryPoints.length - 1];
                        const previous = analysisData.trajectoryPoints[analysisData.trajectoryPoints.length - 2];

                        const deltaTime = current.time - previous.time;
                        const deltaY = previous.y - current.y; // 向上為正
                        const deltaX = current.x - previous.x; // 水平位移

                        if (deltaTime > 0) {
                            const velocity = deltaY / deltaTime; // 像素/秒

                            // 轉換為 cm/s (使用運動員身高比例)
                            const height = parseFloat(athleteHeight.value) || 175; // 預設175cm
                            const pixelToCm = height / canvas.height; // 假設人身高大約等於畫面高度
                            const velocityCm = velocity * pixelToCm;

                            analysisData.velocityData.push({
                                time: current.time,
                                value: velocityCm
                            });

                            // 位移數據
                            const centerY = canvas.height / 2;
                            analysisData.displacementData.push({
                                time: current.time,
                                value: (centerY - current.y) * pixelToCm // 相對於中心的位移
                            });
                        }
                    }

                    // 繪製追蹤軌跡
                    const trackingCtx = trackingOverlay.getContext('2d');
                    trackingCtx.clearRect(0, 0, trackingOverlay.width, trackingOverlay.height);

                    // 繪製當前位置
                    trackingCtx.beginPath();
                    trackingCtx.arc(trackResult.x, trackResult.y, 10, 0, Math.PI * 2);

                    // 使用漸變
                    const gradient = trackingCtx.createRadialGradient(
                        trackResult.x, trackResult.y, 0,
                        trackResult.x, trackResult.y, 10
                    );
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0.9)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0.5)');

                    trackingCtx.fillStyle = gradient;
                    trackingCtx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                    trackingCtx.shadowBlur = 8;
                    trackingCtx.fill();

                    // 繪製路徑
                    if (analysisData.trajectoryPoints.length > 1) {
                        trackingCtx.beginPath();
                        trackingCtx.moveTo(
                            analysisData.trajectoryPoints[0].x,
                            analysisData.trajectoryPoints[0].y
                        );

                        for (let i = 1; i < analysisData.trajectoryPoints.length; i++) {
                            trackingCtx.lineTo(
                                analysisData.trajectoryPoints[i].x,
                                analysisData.trajectoryPoints[i].y
                            );
                        }

                        trackingCtx.strokeStyle = 'yellow';
                        trackingCtx.lineWidth = 2;
                        trackingCtx.shadowColor = 'rgba(255, 255, 0, 0.5)';
                        trackingCtx.shadowBlur = 5;
                        trackingCtx.stroke();
                    }

                    // 標記關鍵點
                    for (const [key, frameIndex] of Object.entries(analysisData.keyPoints)) {
                        if (frameIndex >= 0 && frameIndex < analysisData.trajectoryPoints.length) {
                            const point = analysisData.trajectoryPoints[frameIndex];

                            trackingCtx.beginPath();
                            trackingCtx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                            trackingCtx.fillStyle = getKeyPointColor(key);
                            trackingCtx.shadowColor = getKeyPointShadowColor(key);
                            trackingCtx.shadowBlur = 8;
                            trackingCtx.fill();

                            // 添加文字標籤
                            trackingCtx.font = '12px Arial';
                            trackingCtx.fillStyle = 'white';
                            trackingCtx.shadowColor = 'black';
                            trackingCtx.shadowBlur = 3;
                            trackingCtx.fillText(getKeyPointName(key), point.x + 10, point.y);
                        }
                    }
                }

                // 更新進度條
                const progress = ((videoPlayer.currentTime - editParams.startTime) / (editParams.endTime - editParams.startTime)) * 100;
                analysisProgress.style.width = `${progress}%`;

                // 進入下一幀
                trackingParams.currentFrameIndex++;
                videoPlayer.currentTime += 1 / 30; // 假設 30fps

                // 當時間變更完成後繼續處理
                videoPlayer.addEventListener('seeked', function onSeeked() {
                    videoPlayer.removeEventListener('seeked', onSeeked);

                    // 使用 requestAnimationFrame 避免阻塞 UI
                    requestAnimationFrame(trackFrame);
                });
            } catch (error) {
                console.error("幀處理錯誤:", error);
                showNotification("處理影片幀時發生錯誤", "error");

                // 嘗試繼續處理下一幀
                trackingParams.currentFrameIndex++;
                videoPlayer.currentTime += 1 / 30;

                videoPlayer.addEventListener('seeked', function onSeeked() {
                    videoPlayer.removeEventListener('seeked', onSeeked);
                    requestAnimationFrame(trackFrame);
                });
            }
        }

        // 追蹤比較影片中的單個幀
        async function trackCompareFrame() {
            if (!compareTrackingParams.isTracking) return;

            // 檢查是否到達視頻結尾
            if (compareVideoPlayer.currentTime >= compareVideoPlayer.duration) {
                finishCompareTracking();
                return;
            }

            try {
                // 建立一個臨時 canvas 來處理視頻幀
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = compareVideoPlayer.videoWidth;
                canvas.height = compareVideoPlayer.videoHeight;

                // 繪製當前視頻幀
                ctx.drawImage(compareVideoPlayer, 0, 0, canvas.width, canvas.height);

                // 追蹤當前幀中的槓鈴
                const trackResult = trackBarbellInFrame(canvas, compareTrackingParams);

                // 估計骨架姿勢
                let poseResult = null;
                if (poseNetReady && poseNetModel && poseNetAllowed) {
                    try {
                        poseResult = await poseNetModel.estimateSinglePose(canvas, {
                            flipHorizontal: false
                        });

                        // 計算關節角度
                        const kneeJointAngle = calculateJointAngle(poseResult, 'leftHip', 'leftKnee', 'leftAnkle') ||
                            calculateJointAngle(poseResult, 'rightHip', 'rightKnee', 'rightAnkle');

                        const hipJointAngle = calculateJointAngle(poseResult, 'leftShoulder', 'leftHip', 'leftKnee') ||
                            calculateJointAngle(poseResult, 'rightShoulder', 'rightHip', 'rightKnee');

                        const shoulderJointAngle = calculateJointAngle(poseResult, 'leftElbow', 'leftShoulder', 'leftHip') ||
                            calculateJointAngle(poseResult, 'rightElbow', 'rightShoulder', 'rightHip');

                        const elbowJointAngle = calculateJointAngle(poseResult, 'leftWrist', 'leftElbow', 'leftShoulder') ||
                            calculateJointAngle(poseResult, 'rightWrist', 'rightElbow', 'rightShoulder');

                        // 儲存角度數據
                        if (kneeJointAngle) {
                            compareData.angles.knee.push({
                                time: compareVideoPlayer.currentTime,
                                value: kneeJointAngle
                            });
                        }

                        if (hipJointAngle) {
                            compareData.angles.hip.push({
                                time: compareVideoPlayer.currentTime,
                                value: hipJointAngle
                            });
                        }

                        if (shoulderJointAngle) {
                            compareData.angles.shoulder.push({
                                time: compareVideoPlayer.currentTime,
                                value: shoulderJointAngle
                            });
                        }

                        if (elbowJointAngle) {
                            compareData.angles.elbow.push({
                                time: compareVideoPlayer.currentTime,
                                value: elbowJointAngle
                            });
                        }

                        // 儲存姿勢
                        compareData.poses.push(poseResult);

                        // 如果啟用了骨架顯示，繪製骨架
                        if (compareTrackingParams.showSkeleton) {
                            drawSkeleton(poseResult, compareSkeletonOverlay, compareTrackingParams.activeJoints);
                        }

                        // 更新角度顯示
                        if (compareTrackingParams.showAngles) {
                            updateCompareAngleDisplay(poseResult);
                        }
                    } catch (error) {
                        console.error("比較影片姿勢估計錯誤:", error);
                    }
                }

                if (trackResult) {
                    // 儲存追蹤結果
                    compareData.trajectoryPoints.push({
                        x: trackResult.x,
                        y: trackResult.y,
                        frame: compareTrackingParams.currentFrameIndex,
                        time: compareVideoPlayer.currentTime
                    });

                    // 儲存時間點
                    compareData.timePoints.push(compareVideoPlayer.currentTime);

                    // 計算速度和位移（從第二幀開始）
                    if (compareData.trajectoryPoints.length > 1) {
                        const current = compareData.trajectoryPoints[compareData.trajectoryPoints.length - 1];
                        const previous = compareData.trajectoryPoints[compareData.trajectoryPoints.length - 2];

                        const deltaTime = current.time - previous.time;
                        const deltaY = previous.y - current.y; // 向上為正
                        const deltaX = current.x - previous.x; // 水平位移

                        if (deltaTime > 0) {
                            const velocity = deltaY / deltaTime; // 像素/秒

                            // 轉換為 cm/s (使用運動員身高比例)
                            const height = parseFloat(athleteHeight.value) || 175; // 預設175cm
                            const pixelToCm = height / canvas.height; // 假設人身高大約等於畫面高度
                            const velocityCm = velocity * pixelToCm;

                            compareData.velocityData.push({
                                time: current.time,
                                value: velocityCm
                            });

                            // 位移數據
                            const centerY = canvas.height / 2;
                            compareData.displacementData.push({
                                time: current.time,
                                value: (centerY - current.y) * pixelToCm // 相對於中心的位移
                            });
                        }
                    }

                    // 繪製追蹤軌跡
                    const trackingCtx = compareOverlay.getContext('2d');
                    trackingCtx.clearRect(0, 0, compareOverlay.width, compareOverlay.height);

                    // 繪製當前位置
                    trackingCtx.beginPath();
                    trackingCtx.arc(trackResult.x, trackResult.y, 10, 0, Math.PI * 2);

                    // 使用漸變
                    const gradient = trackingCtx.createRadialGradient(
                        trackResult.x, trackResult.y, 0,
                        trackResult.x, trackResult.y, 10
                    );
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0.9)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0.5)');

                    trackingCtx.fillStyle = gradient;
                    trackingCtx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                    trackingCtx.shadowBlur = 8;
                    trackingCtx.fill();

                    // 繪製路徑
                    if (compareData.trajectoryPoints.length > 1) {
                        trackingCtx.beginPath();
                        trackingCtx.moveTo(
                            compareData.trajectoryPoints[0].x,
                            compareData.trajectoryPoints[0].y
                        );

                        for (let i = 1; i < compareData.trajectoryPoints.length; i++) {
                            trackingCtx.lineTo(
                                compareData.trajectoryPoints[i].x,
                                compareData.trajectoryPoints[i].y
                            );
                        }

                        trackingCtx.strokeStyle = 'yellow';
                        trackingCtx.lineWidth = 2;
                        trackingCtx.shadowColor = 'rgba(255, 255, 0, 0.5)';
                        trackingCtx.shadowBlur = 5;
                        trackingCtx.stroke();
                    }

                    // 標記關鍵點
                    for (const [key, frameIndex] of Object.entries(compareData.keyPoints)) {
                        if (frameIndex >= 0 && frameIndex < compareData.trajectoryPoints.length) {
                            const point = compareData.trajectoryPoints[frameIndex];

                            trackingCtx.beginPath();
                            trackingCtx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                            trackingCtx.fillStyle = getKeyPointColor(key);
                            trackingCtx.shadowColor = getKeyPointShadowColor(key);
                            trackingCtx.shadowBlur = 8;
                            trackingCtx.fill();

                            // 添加文字標籤
                            trackingCtx.font = '12px Arial';
                            trackingCtx.fillStyle = 'white';
                            trackingCtx.shadowColor = 'black';
                            trackingCtx.shadowBlur = 3;
                            trackingCtx.fillText(getKeyPointName(key), point.x + 10, point.y);
                        }
                    }
                }

                // 更新進度條
                const progress = (compareVideoPlayer.currentTime / compareVideoPlayer.duration) * 100;
                compareProgress.style.width = `${progress}%`;

                // 進入下一幀
                compareTrackingParams.currentFrameIndex++;
                compareVideoPlayer.currentTime += 1 / 30; // 假設 30fps

                // 當時間變更完成後繼續處理
                compareVideoPlayer.addEventListener('seeked', function onSeeked() {
                    compareVideoPlayer.removeEventListener('seeked', onSeeked);

                    // 使用 requestAnimationFrame 避免阻塞 UI
                    requestAnimationFrame(trackCompareFrame);
                });
            } catch (error) {
                console.error("比較影片幀處理錯誤:", error);
                showNotification("處理比較影片幀時發生錯誤", "error");

                // 嘗試繼續處理下一幀
                compareTrackingParams.currentFrameIndex++;
                compareVideoPlayer.currentTime += 1 / 30;

                compareVideoPlayer.addEventListener('seeked', function onSeeked() {
                    compareVideoPlayer.removeEventListener('seeked', onSeeked);
                    requestAnimationFrame(trackCompareFrame);
                });
            }
        }

        // 使用 OpenCV 在幀中追蹤槓鈴
        function trackBarbellInFrame(canvas, params) {
            if (!opencvReady) {
                console.error("OpenCV 尚未準備好");
                showNotification("OpenCV 尚未準備好，請重試", "error");
                return null;
            }

            try {
                // 獲取 canvas 的像素數據
                const ctx = canvas.getContext('2d');
                const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // 轉換為 OpenCV Mat
                const src = cv.matFromImageData(imgData);

                // 預處理：轉換為 RGB 然後 HSV
                const rgbMat = new cv.Mat();
                cv.cvtColor(src, rgbMat, cv.COLOR_RGBA2RGB);

                const hsvMat = new cv.Mat();
                cv.cvtColor(rgbMat, hsvMat, cv.COLOR_RGB2HSV);

                // 使用 HSV 顏色範圍進行遮罩
                const mask = new cv.Mat();
                const low = new cv.Mat(1, 3, cv.CV_8UC1);
                const high = new cv.Mat(1, 3, cv.CV_8UC1);

                // 設定 HSV 範圍
                low.data[0] = params.HSV_min[0];
                low.data[1] = params.HSV_min[1];
                low.data[2] = params.HSV_min[2];

                high.data[0] = params.HSV_max[0];
                high.data[1] = params.HSV_max[1];
                high.data[2] = params.HSV_max[2];

                // 創建遮罩
                cv.inRange(hsvMat, low, high, mask);

                // 應用形態學操作來減少噪音
                const kernel = cv.Mat.ones(5, 5, cv.CV_8U);
                const morphed = new cv.Mat();

                cv.morphologyEx(mask, morphed, cv.MORPH_OPEN, kernel);
                cv.morphologyEx(morphed, morphed, cv.MORPH_CLOSE, kernel);

                // 應用高斯模糊減少噪點
                const blurred = new cv.Mat();
                cv.GaussianBlur(morphed, blurred, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);

                // 尋找輪廓
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();

                cv.findContours(blurred, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let largestContourIndex = -1;
                let largestContourArea = 0;

                // 尋找最大的輪廓
                for (let i = 0; i < contours.size(); ++i) {
                    const contour = contours.get(i);
                    const area = cv.contourArea(contour);

                    if (area > largestContourArea) {
                        largestContourArea = area;
                        largestContourIndex = i;
                    }
                }

                let result = null;

                // 如果找到了輪廓
                if (largestContourIndex !== -1) {
                    // 計算輪廓的質心
                    const moments = cv.moments(contours.get(largestContourIndex));
                    if (moments.m00 !== 0) {
                        const centerX = moments.m10 / moments.m00;
                        const centerY = moments.m01 / moments.m00;

                        result = { x: centerX, y: centerY };
                    }
                }

                // 如果沒有找到適合的輪廓，使用最後已知的位置
                if (!result && params.currentFrameIndex > 0) {
                    const previousPoint = params === trackingParams
                        ? analysisData.trajectoryPoints[analysisData.trajectoryPoints.length - 1]
                        : compareData.trajectoryPoints[compareData.trajectoryPoints.length - 1];

                    if (previousPoint) {
                        // 使用簡單的光流假設：槓鈴不會大幅度移動
                        result = { x: previousPoint.x, y: previousPoint.y };
                    }
                } else if (!result) {
                    // 如果是第一幀且沒找到，使用用戶選擇的點
                    result = { x: params.trackPoint.x, y: params.trackPoint.y };
                }

                // 釋放 OpenCV 資源
                src.delete();
                rgbMat.delete();
                hsvMat.delete();
                mask.delete();
                low.delete();
                high.delete();
                kernel.delete();
                morphed.delete();
                blurred.delete();
                contours.delete();
                hierarchy.delete();

                return result;
            } catch (err) {
                console.error("OpenCV 追蹤錯誤:", err);
                showNotification("影像處理錯誤，請重試", "error");
                return null;
            }
        }

        // 完成追蹤
        function finishTracking() {
            trackingParams.isTracking = false;

            // 更新 UI
            loadingIndicator.classList.add('hidden');
            trackBarbell.classList.remove('hidden');
            stopTracking.classList.add('hidden');

            // 生成分析數據
            generateAnalysisData();

            // 顯示分析結果
            drawTrajectory(trajectoryCanvas, analysisData.trajectoryPoints);
            createVelocityChart();
            createPowerChart();
            createDisplacementChart();
            createAnglesChart();
            updateMetricsDisplay();

            // 回到視頻開頭
            videoPlayer.currentTime = editParams.startTime;
            videoPlayer.play();

            // 顯示完成消息
            showNotification("槓鈴追蹤分析完成！", "success");
        }

        // 完成比較影片追蹤
        function finishCompareTracking() {
            compareTrackingParams.isTracking = false;

            // 更新 UI
            compareLoadingIndicator.classList.add('hidden');
            trackCompare.classList.remove('hidden');
            stopCompareTracking.classList.add('hidden');

            // 生成分析數據
            generateCompareAnalysisData();

            // 顯示比較結果
            drawCompareTrajectory();
            createVelocityCompareChart();
            createPowerCompareChart();
            createDisplacementCompareChart();
            createAnglesCompareChart();
            updateCompareMetricsDisplay();

            // 回到視頻開頭
            compareVideoPlayer.currentTime = 0;
            compareVideoPlayer.play();

            // 顯示完成消息
            showNotification("比較影片槓鈴追蹤分析完成！", "success");
        }

        // 停止追蹤
        stopTracking.addEventListener('click', function () {
            trackingParams.isTracking = false;
            finishTracking();
        });

        // 停止比較追蹤
        stopCompareTracking.addEventListener('click', function () {
            compareTrackingParams.isTracking = false;
            finishCompareTracking();
        });

        // 重設追蹤
        resetTracking.addEventListener('click', function () {
            // 確認對話框
            if (!confirm("確定要重設所有追蹤數據嗎？此操作無法撤銷。")) {
                return;
            }

            // 清空 canvas
            const ctx = trackingOverlay.getContext('2d');
            ctx.clearRect(0, 0, trackingOverlay.width, trackingOverlay.height);

            const skeletonCtx = skeletonOverlay.getContext('2d');
            skeletonCtx.clearRect(0, 0, skeletonOverlay.width, skeletonOverlay.height);

            // 重設追蹤參數
            trackingParams.isTracking = false;
            trackingParams.isPointSelected = false;
            trackingParams.currentFrameIndex = 0;

            // 清空數據
            analysisData.trajectoryPoints = [];
            analysisData.velocityData = [];
            analysisData.powerData = [];
            analysisData.displacementData = [];
            analysisData.timePoints = [];
            analysisData.poses = [];
            analysisData.angles = {
                knee: [],
                hip: [],
                shoulder: [],
                elbow: []
            };
            analysisData.keyPoints = {
                start: -1,
                firstPull: -1,
                powerPosition: -1,
                secondPull: -1,
                catch: -1,
                liftStart: -1
            };

            // 重設 UI
            trackBarbell.classList.remove('hidden');
            stopTracking.classList.add('hidden');
            markKeyPoint.classList.add('hidden');
            keyPointType.classList.add('hidden');
            loadingIndicator.classList.add('hidden');

            // 清空圖表
            if (velocityChartInstance) velocityChartInstance.destroy();
            if (powerChartInstance) powerChartInstance.destroy();
            if (displacementChartInstance) displacementChartInstance.destroy();
            if (anglesChartInstance) anglesChartInstance.destroy();

            // 清空圖表Canvas
            const trajectoryCtx = trajectoryCanvas.getContext('2d');
            trajectoryCtx.clearRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);

            // 清空指標顯示
            maxHeight.textContent = "-";
            liftEfficiency.textContent = "-";
            firstPullTime.textContent = "-";
            secondPullTime.textContent = "-";
            powerKneeAngle.textContent = "-";
            powerHipAngle.textContent = "-";
            maxVelocity.textContent = "-";
            maxPower.textContent = "-";

            // 顯示重設成功消息
            showNotification("追蹤數據已重設", "info");
        });

        // 重設比較追蹤
        resetCompareTracking.addEventListener('click', function () {
            // 確認對話框
            if (!confirm("確定要重設所有比較影片追蹤數據嗎？此操作無法撤銷。")) {
                return;
            }

            // 清空 canvas
            const ctx = compareOverlay.getContext('2d');
            ctx.clearRect(0, 0, compareOverlay.width, compareOverlay.height);

            const skeletonCtx = compareSkeletonOverlay.getContext('2d');
            skeletonCtx.clearRect(0, 0, compareSkeletonOverlay.width, compareSkeletonOverlay.height);

            // 重設追蹤參數
            compareTrackingParams.isTracking = false;
            compareTrackingParams.isPointSelected = false;
            compareTrackingParams.currentFrameIndex = 0;

            // 清空數據
            compareData.trajectoryPoints = [];
            compareData.velocityData = [];
            compareData.powerData = [];
            compareData.displacementData = [];
            compareData.timePoints = [];
            compareData.poses = [];
            compareData.angles = {
                knee: [],
                hip: [],
                shoulder: [],
                elbow: []
            };
            compareData.keyPoints = {
                start: -1,
                firstPull: -1,
                powerPosition: -1,
                secondPull: -1,
                catch: -1,
                liftStart: -1
            };

            // 重設 UI
            trackCompare.classList.remove('hidden');
            stopCompareTracking.classList.add('hidden');
            markCompareKeyPoint.classList.add('hidden');
            compareKeyPointType.classList.add('hidden');
            compareLoadingIndicator.classList.add('hidden');

            // 清空比較圖表
            if (velocityCompareChartInstance) velocityCompareChartInstance.destroy();
            if (powerCompareChartInstance) powerCompareChartInstance.destroy();
            if (displacementCompareChartInstance) displacementCompareChartInstance.destroy();
            if (anglesCompareChartInstance) anglesCompareChartInstance.destroy();

            // 清空圖表Canvas
            const trajectoryCtx = trajectoryCompareCanvas.getContext('2d');
            trajectoryCtx.clearRect(0, 0, trajectoryCompareCanvas.width, trajectoryCompareCanvas.height);

            // 清空比較指標顯示
            compMaxHeight.textContent = "-";
            compLiftEfficiency.textContent = "-";
            compMaxVelocity.textContent = "-";
            compMaxPower.textContent = "-";
            compPowerKneeAngle.textContent = "-";
            compPowerHipAngle.textContent = "-";

            // 顯示重設成功消息
            showNotification("比較影片追蹤數據已重設", "info");
        });

        // 標記關鍵點
        markKeyPoint.addEventListener('click', function () {
            const type = keyPointType.value;

            if (!analysisData.trajectoryPoints.length) {
                showNotification('請先追蹤槓鈴', 'warning');
                return;
            }

            // 獲取當前幀索引
            const currentTime = videoPlayer.currentTime;
            let bestIndex = 0;
            let minTimeDiff = Infinity;

            // 尋找最接近當前時間的幀
            for (let i = 0; i < analysisData.timePoints.length; i++) {
                const diff = Math.abs(analysisData.timePoints[i] - currentTime);
                if (diff < minTimeDiff) {
                    minTimeDiff = diff;
                    bestIndex = i;
                }
            }

            // 設置關鍵點
            analysisData.keyPoints[type] = bestIndex;

            // 更新軌跡顯示
            drawTrajectory(trajectoryCanvas, analysisData.trajectoryPoints);

            // 重新繪製圖表
            createVelocityChart();
            createPowerChart();
            createDisplacementChart();
            createAnglesChart();

            // 在視頻上顯示關鍵點
            const ctx = trackingOverlay.getContext('2d');
            const point = analysisData.trajectoryPoints[bestIndex];

            // 閃爍效果
            const flash = (count, isVisible) => {
                if (count <= 0) return;

                setTimeout(() => {
                    if (isVisible) {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 15, 0, Math.PI * 2);
                        ctx.fillStyle = getKeyPointColor(type);
                        ctx.shadowColor = getKeyPointShadowColor(type);
                        ctx.shadowBlur = 15;
                        ctx.fill();

                        // 添加文字標籤
                        ctx.font = '16px Arial';
                        ctx.fillStyle = 'white';
                        ctx.shadowColor = 'black';
                        ctx.shadowBlur = 5;
                        ctx.fillText(getKeyPointName(type), point.x + 20, point.y);
                    } else {
                        // 清除後重繪所有點
                        const allPoints = trackingOverlay.getContext('2d');
                        allPoints.clearRect(0, 0, trackingOverlay.width, trackingOverlay.height);

                        // 重繪路徑
                        if (analysisData.trajectoryPoints.length > 1) {
                            allPoints.beginPath();
                            allPoints.moveTo(
                                analysisData.trajectoryPoints[0].x,
                                analysisData.trajectoryPoints[0].y
                            );

                            for (let i = 1; i < analysisData.trajectoryPoints.length; i++) {
                                allPoints.lineTo(
                                    analysisData.trajectoryPoints[i].x,
                                    analysisData.trajectoryPoints[i].y
                                );
                            }

                            allPoints.strokeStyle = 'yellow';
                            allPoints.lineWidth = 2;
                            allPoints.shadowColor = 'rgba(255, 255, 0, 0.5)';
                            allPoints.shadowBlur = 5;
                            allPoints.stroke();
                        }

                        // 重繪其他關鍵點
                        for (const [k, idx] of Object.entries(analysisData.keyPoints)) {
                            if (idx >= 0 && idx < analysisData.trajectoryPoints.length) {
                                const p = analysisData.trajectoryPoints[idx];

                                allPoints.beginPath();
                                allPoints.arc(p.x, p.y, 8, 0, Math.PI * 2);
                                allPoints.fillStyle = getKeyPointColor(k);
                                allPoints.shadowColor = getKeyPointShadowColor(k);
                                allPoints.shadowBlur = 8;
                                allPoints.fill();

                                // 添加文字標籤
                                allPoints.font = '12px Arial';
                                allPoints.fillStyle = 'white';
                                allPoints.shadowColor = 'black';
                                allPoints.shadowBlur = 3;
                                allPoints.fillText(getKeyPointName(k), p.x + 10, p.y);
                            }
                        }
                    }

                    flash(count - 1, !isVisible);
                }, 200);
            };

            flash(5, true);

            // 如果已標記了足夠的關鍵點，更新分析指標
            if (analysisData.keyPoints.powerPosition >= 0 ||
                analysisData.keyPoints.firstPull >= 0 && analysisData.keyPoints.secondPull >= 0) {
                updateMetricsDisplay();
            }

            // 顯示標記成功信息
            showNotification(`已標記${getKeyPointName(type)}`, "success");
        });

        // 標記比較影片關鍵點
        markCompareKeyPoint.addEventListener('click', function () {
            const type = compareKeyPointType.value;

            if (!compareData.trajectoryPoints.length) {
                showNotification('請先追蹤比較影片中的槓鈴', 'warning');
                return;
            }

            // 獲取當前幀索引
            const currentTime = compareVideoPlayer.currentTime;
            let bestIndex = 0;
            let minTimeDiff = Infinity;

            // 尋找最接近當前時間的幀
            for (let i = 0; i < compareData.timePoints.length; i++) {
                const diff = Math.abs(compareData.timePoints[i] - currentTime);
                if (diff < minTimeDiff) {
                    minTimeDiff = diff;
                    bestIndex = i;
                }
            }

            // 設置關鍵點
            compareData.keyPoints[type] = bestIndex;

            // 更新比較顯示
            drawCompareTrajectory();
            createVelocityCompareChart();
            createPowerCompareChart();
            createDisplacementCompareChart();
            createAnglesCompareChart();

            // 在視頻上顯示關鍵點
            const ctx = compareOverlay.getContext('2d');
            const point = compareData.trajectoryPoints[bestIndex];

            // 閃爍效果
            const flash = (count, isVisible) => {
                if (count <= 0) return;

                setTimeout(() => {
                    if (isVisible) {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 15, 0, Math.PI * 2);
                        ctx.fillStyle = getKeyPointColor(type);
                        ctx.shadowColor = getKeyPointShadowColor(type);
                        ctx.shadowBlur = 15;
                        ctx.fill();

                        // 添加文字標籤
                        ctx.font = '16px Arial';
                        ctx.fillStyle = 'white';
                        ctx.shadowColor = 'black';
                        ctx.shadowBlur = 5;
                        ctx.fillText(getKeyPointName(type), point.x + 20, point.y);
                    } else {
                        // 清除後重繪所有點
                        const allPoints = compareOverlay.getContext('2d');
                        allPoints.clearRect(0, 0, compareOverlay.width, compareOverlay.height);

                        // 重繪路徑
                        if (compareData.trajectoryPoints.length > 1) {
                            allPoints.beginPath();
                            allPoints.moveTo(
                                compareData.trajectoryPoints[0].x,
                                compareData.trajectoryPoints[0].y
                            );

                            for (let i = 1; i < compareData.trajectoryPoints.length; i++) {
                                allPoints.lineTo(
                                    compareData.trajectoryPoints[i].x,
                                    compareData.trajectoryPoints[i].y
                                );
                            }

                            allPoints.strokeStyle = 'yellow';
                            allPoints.lineWidth = 2;
                            allPoints.shadowColor = 'rgba(255, 255, 0, 0.5)';
                            allPoints.shadowBlur = 5;
                            allPoints.stroke();
                        }

                        // 重繪其他關鍵點
                        for (const [k, idx] of Object.entries(compareData.keyPoints)) {
                            if (idx >= 0 && idx < compareData.trajectoryPoints.length) {
                                const p = compareData.trajectoryPoints[idx];

                                allPoints.beginPath();
                                allPoints.arc(p.x, p.y, 8, 0, Math.PI * 2);
                                allPoints.fillStyle = getKeyPointColor(k);
                                allPoints.shadowColor = getKeyPointShadowColor(k);
                                allPoints.shadowBlur = 8;
                                allPoints.fill();

                                // 添加文字標籤
                                allPoints.font = '12px Arial';
                                allPoints.fillStyle = 'white';
                                allPoints.shadowColor = 'black';
                                allPoints.shadowBlur = 3;
                                allPoints.fillText(getKeyPointName(k), p.x + 10, p.y);
                            }
                        }
                    }

                    flash(count - 1, !isVisible);
                }, 200);
            };

            flash(5, true);

            // 如果已標記了足夠的關鍵點，更新分析指標
            if (compareData.keyPoints.powerPosition >= 0 ||
                compareData.keyPoints.firstPull >= 0 && compareData.keyPoints.secondPull >= 0) {
                updateCompareMetricsDisplay();
            }

            // 顯示標記成功信息
            showNotification(`已標記比較影片${getKeyPointName(type)}`, "success");
        });

        // 生成分析數據
        function generateAnalysisData() {
            const weight = parseFloat(weightInput.value) || 100; // 預設100公斤

            // 計算功率 (力 * 速度)
            // 力 = 質量 * 重力加速度 + 質量 * 加速度
            const gravity = 9.81; // m/s^2

            // 功率數據
            analysisData.powerData = [];

            for (let i = 1; i < analysisData.velocityData.length; i++) {
                const v1 = analysisData.velocityData[i - 1].value;
                const v2 = analysisData.velocityData[i].value;
                const t1 = analysisData.velocityData[i - 1].time;
                const t2 = analysisData.velocityData[i].time;

                const deltaTime = t2 - t1;
                const acceleration = deltaTime > 0 ? (v2 - v1) / deltaTime : 0;

                // 力 (牛頓) = 質量 (公斤) * 加速度 (m/s^2)
                const force = weight * (gravity + acceleration);

                // 功率 (瓦特) = 力 (牛頓) * 速度 (m/s)
                const power = force * (analysisData.velocityData[i].value / 100); // 轉換cm為m

                analysisData.powerData.push({
                    time: analysisData.velocityData[i].time,
                    value: power
                });
            }

            // 計算附加指標
            calculateMetrics(analysisData);
        }

        // 生成比較影片分析數據
        function generateCompareAnalysisData() {
            const weight = parseFloat(weightInput.value) || 100; // 使用相同重量

            // 計算功率
            const gravity = 9.81; // m/s^2

            // 功率數據
            compareData.powerData = [];

            for (let i = 1; i < compareData.velocityData.length; i++) {
                const v1 = compareData.velocityData[i - 1].value;
                const v2 = compareData.velocityData[i].value;
                const t1 = compareData.velocityData[i - 1].time;
                const t2 = compareData.velocityData[i].time;

                const deltaTime = t2 - t1;
                const acceleration = deltaTime > 0 ? (v2 - v1) / deltaTime : 0;

                // 力 (牛頓) = 質量 (公斤) * 加速度 (m/s^2)
                const force = weight * (gravity + acceleration);

                // 功率 (瓦特) = 力 (牛頓) * 速度 (m/s)
                const power = force * (compareData.velocityData[i].value / 100); // 轉換cm為m

                compareData.powerData.push({
                    time: compareData.velocityData[i].time,
                    value: power
                });
            }

            // 計算附加指標
            calculateMetrics(compareData);
        }

        // 計算附加指標
        function calculateMetrics(data) {
            // 最大槓鈴高度 (以位移數據中的最高點表示)
            if (data.displacementData.length > 0) {
                const maxDisplacement = Math.max(...data.displacementData.map(d => d.value));
                data.metrics.maxHeight = maxDisplacement;
            }

            // 最大速度
            if (data.velocityData.length > 0) {
                const maxVelocity = Math.max(...data.velocityData.map(d => d.value));
                data.metrics.maxVelocity = maxVelocity;
            }

            // 最大功率
            if (data.powerData.length > 0) {
                const maxPower = Math.max(...data.powerData.map(d => d.value));
                data.metrics.maxPower = maxPower;
            }

            // 拉起效率 (垂直/水平位移比)
            if (data.trajectoryPoints.length > 1) {
                // 計算總垂直位移
                const startY = data.trajectoryPoints[0].y;
                const minY = Math.min(...data.trajectoryPoints.map(p => p.y));
                const totalVertical = startY - minY;

                // 計算最大水平位移
                const startX = data.trajectoryPoints[0].x;
                const maxHorizontalDeviation = Math.max(
                    ...data.trajectoryPoints.map(p => Math.abs(p.x - startX))
                );

                // 計算效率比 (垂直/水平)
                if (maxHorizontalDeviation > 0) {
                    data.metrics.liftEfficiency = totalVertical / maxHorizontalDeviation;
                }
            }

            // 動作時間
            if (data.keyPoints.firstPull >= 0 && data.keyPoints.powerPosition >= 0) {
                const firstPullTime = data.timePoints[data.keyPoints.firstPull];
                const powerPositionTime = data.timePoints[data.keyPoints.powerPosition];
                data.metrics.firstPullTime = powerPositionTime - firstPullTime;
            }

            if (data.keyPoints.powerPosition >= 0 && data.keyPoints.secondPull >= 0) {
                const powerPositionTime = data.timePoints[data.keyPoints.powerPosition];
                const secondPullTime = data.timePoints[data.keyPoints.secondPull];
                data.metrics.secondPullTime = secondPullTime - powerPositionTime;
            }

            // 發力點時的關節角度
            if (data.keyPoints.powerPosition >= 0 && data.poses.length > data.keyPoints.powerPosition) {
                const powerPose = data.poses[data.keyPoints.powerPosition];

                const kneeJointAngle = calculateJointAngle(powerPose, 'leftHip', 'leftKnee', 'leftAnkle') ||
                    calculateJointAngle(powerPose, 'rightHip', 'rightKnee', 'rightAnkle');

                const hipJointAngle = calculateJointAngle(powerPose, 'leftShoulder', 'leftHip', 'leftKnee') ||
                    calculateJointAngle(powerPose, 'rightShoulder', 'rightHip', 'rightKnee');

                if (kneeJointAngle) data.metrics.powerKneeAngle = kneeJointAngle;
                if (hipJointAngle) data.metrics.powerHipAngle = hipJointAngle;
            }
        }

        // 更新指標顯示
        function updateMetricsDisplay() {
            const metrics = analysisData.metrics;

            // 最大槓鈴高度
            maxHeight.textContent = metrics.maxHeight.toFixed(1) + " cm";

            // 拉起效率
            liftEfficiency.textContent = metrics.liftEfficiency.toFixed(2);

            // 第一拉時間
            if (metrics.firstPullTime > 0) {
                firstPullTime.textContent = metrics.firstPullTime.toFixed(2) + " 秒";
            }

            // 第二拉時間
            if (metrics.secondPullTime > 0) {
                secondPullTime.textContent = metrics.secondPullTime.toFixed(2) + " 秒";
            }

            // 發力點關節角度
            if (metrics.powerKneeAngle > 0) {
                powerKneeAngle.textContent = metrics.powerKneeAngle.toFixed(1) + "°";
            }

            if (metrics.powerHipAngle > 0) {
                powerHipAngle.textContent = metrics.powerHipAngle.toFixed(1) + "°";
            }

            // 最大速度和功率
            maxVelocity.textContent = metrics.maxVelocity.toFixed(1) + " cm/s";
            maxPower.textContent = metrics.maxPower.toFixed(1) + " W";

            // 更新比較頁面的指標
            origMaxHeight.textContent = metrics.maxHeight.toFixed(1) + " cm";
            origLiftEfficiency.textContent = metrics.liftEfficiency.toFixed(2);
            origMaxVelocity.textContent = metrics.maxVelocity.toFixed(1) + " cm/s";
            origMaxPower.textContent = metrics.maxPower.toFixed(1) + " W";
            origPowerKneeAngle.textContent = metrics.powerKneeAngle > 0 ? metrics.powerKneeAngle.toFixed(1) + "°" : "-";
            origPowerHipAngle.textContent = metrics.powerHipAngle > 0 ? metrics.powerHipAngle.toFixed(1) + "°" : "-";
        }

        // 更新比較指標顯示
        function updateCompareMetricsDisplay() {
            const metrics = compareData.metrics;

            // 更新比較頁面的指標
            compMaxHeight.textContent = metrics.maxHeight.toFixed(1) + " cm";
            compLiftEfficiency.textContent = metrics.liftEfficiency.toFixed(2);
            compMaxVelocity.textContent = metrics.maxVelocity.toFixed(1) + " cm/s";
            compMaxPower.textContent = metrics.maxPower.toFixed(1) + " W";
            compPowerKneeAngle.textContent = metrics.powerKneeAngle > 0 ? metrics.powerKneeAngle.toFixed(1) + "°" : "-";
            compPowerHipAngle.textContent = metrics.powerHipAngle > 0 ? metrics.powerHipAngle.toFixed(1) + "°" : "-";
        }

        // ==================== 分析結果繪製 ====================

        // 繪製軌跡
        function drawTrajectory(canvas, points) {
            if (!canvas || !canvas.getContext) {
                console.error("無法獲取canvas上下文");
                return;
            }

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 設置背景
            ctx.fillStyle = getComputedStyle(canvas).backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 繪製網格
            drawGrid(ctx, canvas.width, canvas.height);

            if (points.length === 0) return;

            // 計算縮放比例
            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));
            const maxY = Math.max(...points.map(p => p.y));

            const padding = 30;
            const scaleX = (canvas.width - padding * 2) / (maxX - minX || 1);
            const scaleY = (canvas.height - padding * 2) / (maxY - minY || 1);

            // 繪製軌跡
            ctx.save();
            ctx.beginPath();

            // 將第一個點移到正確位置
            const scaledX1 = (points[0].x - minX) * scaleX + padding;
            const scaledY1 = (points[0].y - minY) * scaleY + padding;
            ctx.moveTo(scaledX1, scaledY1);

            // 連接所有點
            for (let i = 1; i < points.length; i++) {
                const scaledX = (points[i].x - minX) * scaleX + padding;
                const scaledY = (points[i].y - minY) * scaleY + padding;
                ctx.lineTo(scaledX, scaledY);
            }

            // 美化軌跡線
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 3;
            ctx.shadowColor = 'rgba(0, 0, 255, 0.5)';
            ctx.shadowBlur = 5;
            ctx.stroke();

            // 添加起點和終點標記
            if (points.length > 1) {
                // 起點標記
                const startX = (points[0].x - minX) * scaleX + padding;
                const startY = (points[0].y - minY) * scaleY + padding;

                ctx.beginPath();
                ctx.arc(startX, startY, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#00c853';
                ctx.shadowColor = 'rgba(0, 200, 83, 0.8)';
                ctx.shadowBlur = 8;
                ctx.fill();

                ctx.font = '12px Arial';
                ctx.fillStyle = '#00c853';
                ctx.shadowColor = 'none';
                ctx.shadowBlur = 0;
                ctx.fillText('起點', startX + 8, startY - 8);

                // 終點標記
                const endX = (points[points.length - 1].x - minX) * scaleX + padding;
                const endY = (points[points.length - 1].y - minY) * scaleY + padding;

                ctx.beginPath();
                ctx.arc(endX, endY, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#ff1744';
                ctx.shadowColor = 'rgba(255, 23, 68, 0.8)';
                ctx.shadowBlur = 8;
                ctx.fill();

                ctx.font = '12px Arial';
                ctx.fillStyle = '#ff1744';
                ctx.shadowColor = 'none';
                ctx.shadowBlur = 0;
                ctx.fillText('終點', endX + 8, endY - 8);
            }

            // 標記關鍵點
            const keyPoints = [
                { index: analysisData.keyPoints.start, color: 'green', label: '起始點' },
                { index: analysisData.keyPoints.firstPull, color: 'orange', label: '第一拉' },
                { index: analysisData.keyPoints.powerPosition, color: 'red', label: '發力點' },
                { index: analysisData.keyPoints.secondPull, color: 'purple', label: '第二拉' },
                { index: analysisData.keyPoints.catch, color: 'blue', label: '接槓點' },
                { index: analysisData.keyPoints.liftStart, color: 'teal', label: '拉起槓鈴時' }
            ];

            keyPoints.forEach(kp => {
                if (kp.index >= 0 && kp.index < points.length) {
                    const p = points[kp.index];
                    const x = (p.x - minX) * scaleX + padding;
                    const y = (p.y - minY) * scaleY + padding;

                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = kp.color;
                    ctx.shadowColor = getShadowColorFromColor(kp.color);
                    ctx.shadowBlur = 10;
                    ctx.fill();

                    ctx.font = '14px Arial';
                    ctx.fillStyle = kp.color;
                    ctx.shadowColor = 'none';
                    ctx.shadowBlur = 0;
                    ctx.fillText(kp.label, x + 12, y);
                }
            });

            // 添加坐標軸標籤
            ctx.font = '14px Arial';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            ctx.fillText('水平位移 (相對比例)', canvas.width / 2, canvas.height - 5);

            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('垂直位移 (相對比例)', 0, 0);
            ctx.restore();

            ctx.restore();
        }

        // 繪製網格
        function drawGrid(ctx, width, height) {
            ctx.save();

            // 網格設置
            const gridSize = 20;
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.lineWidth = 0.5;

            // 水平線
            for (let y = 0; y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // 垂直線
            for (let x = 0; x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            // 中心線
            ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
            ctx.lineWidth = 1;

            // 水平中心線
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();

            // 垂直中心線
            ctx.beginPath();
            ctx.moveTo(width / 2, 0);
            ctx.lineTo(width / 2, height);
            ctx.stroke();

            ctx.restore();
        }

        // 繪製比較軌跡
        function drawCompareTrajectory() {
            const ctx = trajectoryCompareCanvas.getContext('2d');
            ctx.clearRect(0, 0, trajectoryCompareCanvas.width, trajectoryCompareCanvas.height);

            // 設置背景
            ctx.fillStyle = getComputedStyle(trajectoryCompareCanvas).backgroundColor;
            ctx.fillRect(0, 0, trajectoryCompareCanvas.width, trajectoryCompareCanvas.height);

            // 繪製網格
            drawGrid(ctx, trajectoryCompareCanvas.width, trajectoryCompareCanvas.height);

            if (analysisData.trajectoryPoints.length === 0 || compareData.trajectoryPoints.length === 0) return;

            // 計算所有點的範圍
            const allPoints = [...analysisData.trajectoryPoints, ...compareData.trajectoryPoints];
            const minX = Math.min(...allPoints.map(p => p.x));
            const maxX = Math.max(...allPoints.map(p => p.x));
            const minY = Math.min(...allPoints.map(p => p.y));
            const maxY = Math.max(...allPoints.map(p => p.y));

            const padding = 30;
            const scaleX = (trajectoryCompareCanvas.width - padding * 2) / (maxX - minX || 1);
            const scaleY = (trajectoryCompareCanvas.height - padding * 2) / (maxY - minY || 1);

            ctx.save();

            // 繪製原始軌跡
            ctx.beginPath();
            if (analysisData.trajectoryPoints.length > 0) {
                const scaledX1 = (analysisData.trajectoryPoints[0].x - minX) * scaleX + padding;
                const scaledY1 = (analysisData.trajectoryPoints[0].y - minY) * scaleY + padding;
                ctx.moveTo(scaledX1, scaledY1);

                for (let i = 1; i < analysisData.trajectoryPoints.length; i++) {
                    const scaledX = (analysisData.trajectoryPoints[i].x - minX) * scaleX + padding;
                    const scaledY = (analysisData.trajectoryPoints[i].y - minY) * scaleY + padding;
                    ctx.lineTo(scaledX, scaledY);
                }
            }

            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 3;
            ctx.shadowColor = 'rgba(0, 0, 255, 0.5)';
            ctx.shadowBlur = 5;
            ctx.stroke();

            // 繪製比較軌跡
            ctx.beginPath();
            if (compareData.trajectoryPoints.length > 0) {
                const scaledX1 = (compareData.trajectoryPoints[0].x - minX) * scaleX + padding;
                const scaledY1 = (compareData.trajectoryPoints[0].y - minY) * scaleY + padding;
                ctx.moveTo(scaledX1, scaledY1);

                for (let i = 1; i < compareData.trajectoryPoints.length; i++) {
                    const scaledX = (compareData.trajectoryPoints[i].x - minX) * scaleX + padding;
                    const scaledY = (compareData.trajectoryPoints[i].y - minY) * scaleY + padding;
                    ctx.lineTo(scaledX, scaledY);
                }
            }

            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;
            ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
            ctx.shadowBlur = 5;
            ctx.stroke();

            // 繪製圖例
            const legendX = trajectoryCompareCanvas.width - 120;
            const legendY = 30;
            const legendSpacing = 30;

            // 原始影片線條
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 30, legendY);
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 3;
            ctx.shadowColor = 'rgba(0, 0, 255, 0.5)';
            ctx.shadowBlur = 5;
            ctx.stroke();

            ctx.font = '14px Arial';
            ctx.fillStyle = 'blue';
            ctx.shadowColor = 'none';
            ctx.shadowBlur = 0;
            ctx.textAlign = 'left';
            ctx.fillText('原始影片', legendX + 40, legendY + 5);

            // 比較影片線條
            ctx.beginPath();
            ctx.moveTo(legendX, legendY + legendSpacing);
            ctx.lineTo(legendX + 30, legendY + legendSpacing);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;
            ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
            ctx.shadowBlur = 5;
            ctx.stroke();

            ctx.font = '14px Arial';
            ctx.fillStyle = 'red';
            ctx.shadowColor = 'none';
            ctx.shadowBlur = 0;
            ctx.fillText('比較影片', legendX + 40, legendY + legendSpacing + 5);

            // 繪製關鍵點
            function drawKeyPoints(data, color) {
                Object.entries(data.keyPoints).forEach(([key, index]) => {
                    if (index >= 0 && index < data.trajectoryPoints.length) {
                        const point = data.trajectoryPoints[index];
                        const x = (point.x - minX) * scaleX + padding;
                        const y = (point.y - minY) * scaleY + padding;

                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, Math.PI * 2);
                        ctx.fillStyle = getKeyPointColor(key);
                        ctx.shadowColor = getKeyPointShadowColor(key);
                        ctx.shadowBlur = 8;
                        ctx.fill();

                        // 繪製短標籤
                        ctx.font = '12px Arial';
                        ctx.fillStyle = getKeyPointColor(key);
                        ctx.shadowColor = 'none';
                        ctx.shadowBlur = 0;
                        ctx.fillText(getKeyPointShortName(key), x + 7, y);
                    }
                });
            }

            // 繪製兩組關鍵點
            drawKeyPoints(analysisData, 'blue');
            drawKeyPoints(compareData, 'red');

            // 添加坐標軸標籤
            ctx.font = '14px Arial';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'center';
            ctx.fillText('水平位移 (相對比例)', trajectoryCompareCanvas.width / 2, trajectoryCompareCanvas.height - 5);

            ctx.save();
            ctx.translate(15, trajectoryCompareCanvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('垂直位移 (相對比例)', 0, 0);
            ctx.restore();

            ctx.restore();
        }

        // 創建速度圖表
        function createVelocityChart() {
            const ctx = velocityChart.getContext('2d');

            if (velocityChartInstance) {
                velocityChartInstance.destroy();
            }

            if (analysisData.velocityData.length === 0) return;

            const timeLabels = analysisData.velocityData.map(d => d.time);
            const velocityValues = analysisData.velocityData.map(d => d.value);

            // 標記關鍵點位置
            const annotations = {};
            const keyPointsMap = {
                start: '起始點',
                firstPull: '第一拉',
                powerPosition: '發力點',
                secondPull: '第二拉',
                catch: '接槓點',
                liftStart: '拉起槓鈴時'
            };

            Object.entries(analysisData.keyPoints).forEach(([key, index]) => {
                if (index >= 0 && index < analysisData.timePoints.length) {
                    const time = analysisData.timePoints[index];

                    annotations[key] = {
                        type: 'line',
                        scaleID: 'x',
                        value: time,
                        borderColor: getKeyPointColor(key),
                        borderWidth: 2,
                        label: {
                            content: keyPointsMap[key],
                            enabled: true,
                            position: 'top',
                            backgroundColor: getKeyPointColor(key),
                            color: 'white',
                            padding: 5,
                            borderRadius: 3
                        }
                    };
                }
            });

            velocityChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [{
                        label: '速度 (cm/s)',
                        data: velocityValues,
                        borderColor: 'rgba(0, 123, 255, 0.8)',
                        backgroundColor: 'rgba(0, 123, 255, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointBackgroundColor: 'rgba(0, 123, 255, 1)',
                        pointHoverRadius: 5,
                        pointHoverBackgroundColor: 'rgba(0, 123, 255, 1)',
                        pointHoverBorderColor: 'white',
                        pointHoverBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: '速度 (cm/s)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: '時間 (秒)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: annotations
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: {
                                size: 14
                            },
                            bodyFont: {
                                size: 13
                            },
                            displayColors: false,
                            callbacks: {
                                title: function (context) {
                                    return `時間: ${context[0].parsed.x.toFixed(2)} 秒`;
                                },
                                label: function (context) {
                                    return `速度: ${context.parsed.y.toFixed(2)} cm/s`;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                font: {
                                    size: 14
                                }
                            }
                        }
                    }
                }
            });
        }

        // 創建功率圖表
        function createPowerChart() {
            const ctx = powerChart.getContext('2d');

            if (powerChartInstance) {
                powerChartInstance.destroy();
            }

            if (analysisData.powerData.length === 0) return;

            const timeLabels = analysisData.powerData.map(d => d.time);
            const powerValues = analysisData.powerData.map(d => d.value);

            // 標記關鍵點
            const annotations = {};
            const keyPointsMap = {
                start: '起始點',
                firstPull: '第一拉',
                powerPosition: '發力點',
                secondPull: '第二拉',
                catch: '接槓點',
                liftStart: '拉起槓鈴時'
            };

            Object.entries(analysisData.keyPoints).forEach(([key, index]) => {
                if (index >= 0 && index < analysisData.timePoints.length) {
                    const time = analysisData.timePoints[index];

                    annotations[key] = {
                        type: 'line',
                        scaleID: 'x',
                        value: time,
                        borderColor: getKeyPointColor(key),
                        borderWidth: 2,
                        label: {
                            content: keyPointsMap[key],
                            enabled: true,
                            position: 'top',
                            backgroundColor: getKeyPointColor(key),
                            color: 'white',
                            padding: 5,
                            borderRadius: 3
                        }
                    };
                }
            });

            powerChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [{
                        label: '功率 (瓦特)',
                        data: powerValues,
                        borderColor: 'rgba(40, 167, 69, 0.8)',
                        backgroundColor: 'rgba(40, 167, 69, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointBackgroundColor: 'rgba(40, 167, 69, 1)',
                        pointHoverRadius: 5,
                        pointHoverBackgroundColor: 'rgba(40, 167, 69, 1)',
                        pointHoverBorderColor: 'white',
                        pointHoverBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: '功率 (瓦特)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: '時間 (秒)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: annotations
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: {
                                size: 14
                            },
                            bodyFont: {
                                size: 13
                            },
                            displayColors: false,
                            callbacks: {
                                title: function (context) {
                                    return `時間: ${context[0].parsed.x.toFixed(2)} 秒`;
                                },
                                label: function (context) {
                                    return `功率: ${context.parsed.y.toFixed(2)} W`;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                font: {
                                    size: 14
                                }
                            }
                        }
                    }
                }
            });
        }

        // 創建位移圖表
        function createDisplacementChart() {
            const ctx = displacementChart.getContext('2d');

            if (displacementChartInstance) {
                displacementChartInstance.destroy();
            }

            if (analysisData.displacementData.length === 0) return;

            const timeLabels = analysisData.displacementData.map(d => d.time);
            const displacementValues = analysisData.displacementData.map(d => d.value);

            // 標記關鍵點
            const annotations = {};
            const keyPointsMap = {
                start: '起始點',
                firstPull: '第一拉',
                powerPosition: '發力點',
                secondPull: '第二拉',
                catch: '接槓點',
                liftStart: '拉起槓鈴時'
            };

            Object.entries(analysisData.keyPoints).forEach(([key, index]) => {
                if (index >= 0 && index < analysisData.timePoints.length) {
                    const time = analysisData.timePoints[index];

                    annotations[key] = {
                        type: 'line',
                        scaleID: 'x',
                        value: time,
                        borderColor: getKeyPointColor(key),
                        borderWidth: 2,
                        label: {
                            content: keyPointsMap[key],
                            enabled: true,
                            position: 'top',
                            backgroundColor: getKeyPointColor(key),
                            color: 'white',
                            padding: 5,
                            borderRadius: 3
                        }
                    };
                }
            });

            displacementChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [{
                        label: '垂直位移 (cm)',
                        data: displacementValues,
                        borderColor: 'rgba(111, 66, 193, 0.8)',
                        backgroundColor: 'rgba(111, 66, 193, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointBackgroundColor: 'rgba(111, 66, 193, 1)',
                        pointHoverRadius: 5,
                        pointHoverBackgroundColor: 'rgba(111, 66, 193, 1)',
                        pointHoverBorderColor: 'white',
                        pointHoverBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: '垂直位移 (cm)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: '時間 (秒)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: annotations
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: {
                                size: 14
                            },
                            bodyFont: {
                                size: 13
                            },
                            displayColors: false,
                            callbacks: {
                                title: function (context) {
                                    return `時間: ${context[0].parsed.x.toFixed(2)} 秒`;
                                },
                                label: function (context) {
                                    return `位移: ${context.parsed.y.toFixed(2)} cm`;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                font: {
                                    size: 14
                                }
                            }
                        }
                    }
                }
            });
        }

        // 創建角度圖表
        function createAnglesChart() {
            const ctx = anglesChart.getContext('2d');

            if (anglesChartInstance) {
                anglesChartInstance.destroy();
            }

            if (analysisData.angles.knee.length === 0 &&
                analysisData.angles.hip.length === 0 &&
                analysisData.angles.shoulder.length === 0 &&
                analysisData.angles.elbow.length === 0) return;

            // 準備數據集
            const datasets = [];

            if (analysisData.angles.knee.length > 0) {
                datasets.push({
                    label: '膝關節角度',
                    data: analysisData.angles.knee.map(d => ({
                        x: d.time,
                        y: d.value
                    })),
                    borderColor: 'rgba(220, 53, 69, 0.8)',
                    backgroundColor: 'rgba(220, 53, 69, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: false,
                    pointRadius: 3,
                    pointBackgroundColor: 'rgba(220, 53, 69, 1)',
                    pointHoverRadius: 5
                });
            }

            if (analysisData.angles.hip.length > 0) {
                datasets.push({
                    label: '髖關節角度',
                    data: analysisData.angles.hip.map(d => ({
                        x: d.time,
                        y: d.value
                    })),
                    borderColor: 'rgba(40, 167, 69, 0.8)',
                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: false,
                    pointRadius: 3,
                    pointBackgroundColor: 'rgba(40, 167, 69, 1)',
                    pointHoverRadius: 5
                });
            }

            if (analysisData.angles.shoulder.length > 0) {
                datasets.push({
                    label: '肩關節角度',
                    data: analysisData.angles.shoulder.map(d => ({
                        x: d.time,
                        y: d.value
                    })),
                    borderColor: 'rgba(0, 123, 255, 0.8)',
                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: false,
                    pointRadius: 3,
                    pointBackgroundColor: 'rgba(0, 123, 255, 1)',
                    pointHoverRadius: 5
                });
            }

            if (analysisData.angles.elbow.length > 0) {
                datasets.push({
                    label: '肘關節角度',
                    data: analysisData.angles.elbow.map(d => ({
                        x: d.time,
                        y: d.value
                    })),
                    borderColor: 'rgba(255, 193, 7, 0.8)',
                    backgroundColor: 'rgba(255, 193, 7, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: false,
                    pointRadius: 3,
                    pointBackgroundColor: 'rgba(255, 193, 7, 1)',
                    pointHoverRadius: 5
                });
            }

            // 標記關鍵點
            const annotations = {};
            const keyPointsMap = {
                start: '起始點',
                firstPull: '第一拉',
                powerPosition: '發力點',
                secondPull: '第二拉',
                catch: '接槓點',
                liftStart: '拉起槓鈴時'
            };

            Object.entries(analysisData.keyPoints).forEach(([key, index]) => {
                if (index >= 0 && index < analysisData.timePoints.length) {
                    const time = analysisData.timePoints[index];

                    annotations[key] = {
                        type: 'line',
                        scaleID: 'x',
                        value: time,
                        borderColor: getKeyPointColor(key),
                        borderWidth: 2,
                        label: {
                            content: keyPointsMap[key],
                            enabled: true,
                            position: 'top',
                            backgroundColor: getKeyPointColor(key),
                            color: 'white',
                            padding: 5,
                            borderRadius: 3
                        }
                    };
                }
            });
            
            anglesChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: '角度 (度)',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    color: 'rgba(200, 200, 200, 0.2)'
                                },
                                ticks: {
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: '時間 (秒)',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    color: 'rgba(200, 200, 200, 0.2)'
                                },
                                ticks: {
                                    font: {
                                        size: 12
                                    }
                                }
                            }
                        },
                        plugins: {
                            annotation: {
                                annotations: annotations
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleFont: {
                                    size: 14
                                },
                                bodyFont: {
                                    size: 13
                                },
                                callbacks: {
                                    title: function (context) {
                                        return '時間: ${context[0].parsed.x.toFixed(2)} 秒';
                                    },
                                    label: function (context) {
                                        return '${context.dataset.label}: ${context.parsed.y.toFixed(1)}°';
                                    }
                                }
                            },
                            legend: {
                                labels: {
                                    font: {
                                        size: 14
                                    }
                                }
                            }
                        }
                    }
                });
        }

        // 創建速度比較圖表
        function createVelocityCompareChart() {
            const ctx = velocityCompareChart.getContext('2d');

            if (velocityCompareChartInstance) {
                velocityCompareChartInstance.destroy();
            }

            if (analysisData.velocityData.length === 0 || compareData.velocityData.length === 0) return;

            velocityCompareChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: '原始影片速度',
                            data: analysisData.velocityData.map(d => ({
                                x: d.time,
                                y: d.value
                            })),
                            borderColor: 'rgba(0, 123, 255, 0.8)',
                            backgroundColor: 'rgba(0, 123, 255, 0.1)',
                            borderWidth: 3,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 2
                        },
                        {
                            label: '比較影片速度',
                            data: compareData.velocityData.map(d => ({
                                x: d.time,
                                y: d.value
                            })),
                            borderColor: 'rgba(220, 53, 69, 0.8)',
                            backgroundColor: 'rgba(220, 53, 69, 0.1)',
                            borderWidth: 3,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: '速度 (cm/s)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            }
                        },
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: '時間 (秒)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            callbacks: {
                                title: function (context) {
                                    return `時間: ${context[0].parsed.x.toFixed(2)} 秒`;
                                },
                                label: function (context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} cm/s`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // 創建功率比較圖表
        function createPowerCompareChart() {
            const ctx = powerCompareChart.getContext('2d');

            if (powerCompareChartInstance) {
                powerCompareChartInstance.destroy();
            }

            if (analysisData.powerData.length === 0 || compareData.powerData.length === 0) return;

            powerCompareChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: '原始影片功率',
                            data: analysisData.powerData.map(d => ({
                                x: d.time,
                                y: d.value
                            })),
                            borderColor: 'rgba(40, 167, 69, 0.8)',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            borderWidth: 3,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 2
                        },
                        {
                            label: '比較影片功率',
                            data: compareData.powerData.map(d => ({
                                x: d.time,
                                y: d.value
                            })),
                            borderColor: 'rgba(255, 193, 7, 0.8)',
                            backgroundColor: 'rgba(255, 193, 7, 0.1)',
                            borderWidth: 3,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: '功率 (瓦特)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            }
                        },
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: '時間 (秒)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            callbacks: {
                                title: function (context) {
                                    return `時間: ${context[0].parsed.x.toFixed(2)} 秒`;
                                },
                                label: function (context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} W`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // 創建位移比較圖表
        function createDisplacementCompareChart() {
            const ctx = displacementCompareChart.getContext('2d');

            if (displacementCompareChartInstance) {
                displacementCompareChartInstance.destroy();
            }

            if (analysisData.displacementData.length === 0 || compareData.displacementData.length === 0) return;

            displacementCompareChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: '原始影片位移',
                            data: analysisData.displacementData.map(d => ({
                                x: d.time,
                                y: d.value
                            })),
                            borderColor: 'rgba(111, 66, 193, 0.8)',
                            backgroundColor: 'rgba(111, 66, 193, 0.1)',
                            borderWidth: 3,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 2
                        },
                        {
                            label: '比較影片位移',
                            data: compareData.displacementData.map(d => ({
                                x: d.time,
                                y: d.value
                            })),
                            borderColor: 'rgba(23, 162, 184, 0.8)',
                            backgroundColor: 'rgba(23, 162, 184, 0.1)',
                            borderWidth: 3,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: '垂直位移 (cm)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            }
                        },
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: '時間 (秒)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            callbacks: {
                                title: function (context) {
                                    return `時間: ${context[0].parsed.x.toFixed(2)} 秒`;
                                },
                                label: function (context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} cm`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // 創建角度比較圖表
        function createAnglesCompareChart() {
            const ctx = anglesCompareChart.getContext('2d');

            if (anglesCompareChartInstance) {
                anglesCompareChartInstance.destroy();
            }

            if (analysisData.angles.knee.length === 0 && compareData.angles.knee.length === 0) return;

            // 準備數據集
            const datasets = [];

            // 原始影片關節角度
            if (analysisData.angles.knee.length > 0) {
                datasets.push({
                    label: '原始影片-膝關節',
                    data: analysisData.angles.knee.map(d => ({
                        x: d.time,
                        y: d.value
                    })),
                    borderColor: 'rgba(220, 53, 69, 0.8)',
                    backgroundColor: 'rgba(220, 53, 69, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: false,
                    pointRadius: 1
                });
            }

            if (analysisData.angles.hip.length > 0) {
                datasets.push({
                    label: '原始影片-髖關節',
                    data: analysisData.angles.hip.map(d => ({
                        x: d.time,
                        y: d.value
                    })),
                    borderColor: 'rgba(40, 167, 69, 0.8)',
                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: false,
                    pointRadius: 1
                });
            }

            // 比較影片關節角度
            if (compareData.angles.knee.length > 0) {
                datasets.push({
                    label: '比較影片-膝關節',
                    data: compareData.angles.knee.map(d => ({
                        x: d.time,
                        y: d.value
                    })),
                    borderColor: 'rgba(255, 99, 132, 0.8)',
                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: false,
                    pointRadius: 1,
                    borderDash: [5, 5]
                });
            }

            if (compareData.angles.hip.length > 0) {
                datasets.push({
                    label: '比較影片-髖關節',
                    data: compareData.angles.hip.map(d => ({
                        x: d.time,
                        y: d.value
                    })),
                    borderColor: 'rgba(75, 192, 192, 0.8)',
                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: false,
                    pointRadius: 1,
                    borderDash: [5, 5]
                });
            }

            anglesCompareChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: '角度 (度)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            }
                        },
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: '時間 (秒)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(200, 200, 200, 0.2)'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            callbacks: {
                                title: function (context) {
                                    return `時間: ${context[0].parsed.x.toFixed(2)} 秒`;
                                },
                                label: function (context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}°`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // 同步影片功能
        syncVideos.addEventListener('click', function () {
            if (!analysisData.trajectoryPoints.length || !compareData.trajectoryPoints.length) {
                showNotification('請先完成兩個影片的追蹤', 'warning');
                return;
            }

            const syncPointType = syncPoint.value;

            // 檢查是否標記了同步點
            if (analysisData.keyPoints[syncPointType] < 0 || compareData.keyPoints[syncPointType] < 0) {
                showNotification(`請先在兩個影片中標記${getKeyPointName(syncPointType)}`, 'warning');
                return;
            }

            // 獲取同步點時間
            const origTime = analysisData.timePoints[analysisData.keyPoints[syncPointType]];
            const compareTime = compareData.timePoints[compareData.keyPoints[syncPointType]];

            // 設置影片時間
            videoPlayer.currentTime = origTime;
            compareVideoPlayer.currentTime = compareTime;

            // 顯示通知
            showNotification(`已同步影片至${getKeyPointName(syncPointType)}`, 'success');
        });

        // 透明度滑桿
        opacitySlider.addEventListener('input', function () {
            const opacity = this.value / 100;

            // 調整透明度
            compareVideoPlayer.style.opacity = opacity;
        });

        // ==================== Tab 切換功能 ====================

        // 分析標籤頁切換
        const analysisTabs = document.querySelectorAll('#analysisTabs .tab');
        const analysisTabContents = document.querySelectorAll('[id$=\"Tab\"]');

        analysisTabs.forEach(tab => {
            tab.addEventListener('click', function () {
                // 移除所有標籤頁的活躍狀態
                analysisTabs.forEach(t => t.classList.remove('active'));
                analysisTabContents.forEach(content => content.classList.add('hidden'));

                // 添加當前標籤頁的活躍狀態
                this.classList.add('active');

                // 顯示對應的內容
                const tabId = this.getAttribute('data-tab');
                document.getElementById(`${tabId}Tab`).classList.remove('hidden');
            });
        });

        // 比較標籤頁切換
        const comparisonTabs = document.querySelectorAll('#comparisonTabs .tab');
        const comparisonTabContents = document.querySelectorAll('[id$=\"CompareTab\"]');

        comparisonTabs.forEach(tab => {
            tab.addEventListener('click', function () {
                // 移除所有標籤頁的活躍狀態
                comparisonTabs.forEach(t => t.classList.remove('active'));
                comparisonTabContents.forEach(content => content.classList.add('hidden'));

                // 添加當前標籤頁的活躍狀態
                this.classList.add('active');

                // 顯示對應的內容
                const tabId = this.getAttribute('data-tab');
                document.getElementById(`${tabId}Tab`).classList.remove('hidden');
            });
        });

        // ==================== 輔助函數 ====================

        // 取得關鍵點顏色
        function getKeyPointColor(key) {
            switch (key) {
                case 'start': return 'green';
                case 'firstPull': return 'orange';
                case 'powerPosition': return 'red';
                case 'secondPull': return 'purple';
                case 'catch': return 'blue';
                case 'liftStart': return 'teal';
                default: return 'gray';
            }
        }

        // 取得關鍵點陰影顏色
        function getKeyPointShadowColor(key) {
            switch (key) {
                case 'start': return 'rgba(0, 128, 0, 0.8)';
                case 'firstPull': return 'rgba(255, 165, 0, 0.8)';
                case 'powerPosition': return 'rgba(255, 0, 0, 0.8)';
                case 'secondPull': return 'rgba(128, 0, 128, 0.8)';
                case 'catch': return 'rgba(0, 0, 255, 0.8)';
                case 'liftStart': return 'rgba(0, 128, 128, 0.8)';
                default: return 'rgba(128, 128, 128, 0.8)';
            }
        }

        // 取得關鍵點名稱
        function getKeyPointName(key) {
            switch (key) {
                case 'start': return '起始點';
                case 'firstPull': return '第一拉';
                case 'powerPosition': return '發力點';
                case 'secondPull': return '第二拉';
                case 'catch': return '接槓點';
                case 'liftStart': return '拉起槓鈴時';
                default: return '未知點';
            }
        }

        // 取得關鍵點簡短名稱
        function getKeyPointShortName(key) {
            switch (key) {
                case 'start': return 'S';
                case 'firstPull': return '1P';
                case 'powerPosition': return 'PP';
                case 'secondPull': return '2P';
                case 'catch': return 'C';
                case 'liftStart': return 'LS';
                default: return '?';
            }
        }

        // 從顏色取得陰影顏色
        function getShadowColorFromColor(color) {
            return `rgba(0, 0, 0, 0.5)`;
        }

        // 準備初始UI
        document.addEventListener('DOMContentLoaded', function () {
            // 非同步加載核心庫
            if (typeof cv === 'undefined') {
                // OpenCV.js 尚未加載
                document.getElementById('opencvStatus').style.display = 'block';
                document.getElementById('opencvStatus').style.opacity = '1';
            }

            // 初始化選項卡
            const firstAnalysisTab = document.querySelector('#analysisTabs .tab');
            if (firstAnalysisTab) {
                firstAnalysisTab.click();
            }

            const firstComparisonTab = document.querySelector('#comparisonTabs .tab');
            if (firstComparisonTab) {
                firstComparisonTab.click();
            }
        });
    </script>

</body>

</html>", "new_code_block_id": "weightlifting_analysis_complete"}